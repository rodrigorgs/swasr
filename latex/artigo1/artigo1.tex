% http://swasr.googlecode.com/svn/trunk/latex/artigo1/artigo1.pdf
\documentclass{acm_proc_article-sp}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{url}

% Ordem de escrita
%   Resultados
%   Discussão
%   Introdução
%   Materiais e Métodos
%   Abstract
%   Título


% == PLANEJAMENTO DO EXPERIMENTO ==
% 
% INGREDIENTES
%
%   Dois sistemas, um pequeno (?) e um maior (IRPF)
%   Modelos de geração de redes com estrutura de módulos embutida: Rodrigo2008 e Lancichinetti
%   Modelos sem estrutura de módulos: barabasi, bollobas, configuration model.
%
% MODO DE PREPARO
%
%   Analisar métricas dos sistemas (distribuição de graus, distribuição do coeficiente de clustering, correlação de graus).
%   Extrair a arquitetura dos sistemas: quais são os módulos e quais módulos se relacionam. Analisar a distribuição dos tamanhos dos módulos.
%   "Tunar" os parâmetros dos modelos para gerar redes com as mesmas métricas dos sistemas reais
%   Rodar os modelos diversas vezes com os parâmetros encontrados para gerar diversas redes para cada sistema.
%   Comparar redes sintéticas com as redes reais correspondentes através da distância entre redes de Garcia.
% 
% RESULTADOS
%
%   Modelos com estrutura de módulos embutida resultam em redes mais parecidas com as redes reais do que os modelos sem módulos? (Em outras palavras: a informação sobre tamanhos dos módulos e a maneira como os módulos se ligam realmente são uma vantagem?)
%   As redes sintéticas são realistas? Quais as diferenças entre as sintéticas e as reais?
%   Os módulos das redes sintéticas também podem ser decompostos em módulos, como nas redes reais?
%
% O QUE MAIS
%
%   Ver no wiki as observações subjetivas sobre os modelos.
%   Começar pelo sistema pequeno, pra obter resultados mais rápidos, e então reproduzir o método com o sistema grande
%   A implementação do modelo de Rodrigo2008 precisa ser revista pra ficar mais eficiente (está muito lento!)
%   Podemos usar uma distância de Garcia usando o coeficiente de clustering em vez de usar a distância propriamente dita.


\begin{document}
\title{Artigo 1} % Avaliação de modelos de síntese de software
\author{Rodrigo Rocha Gomes e Souza}
\maketitle

\begin{abstract}

% goals, results, and the main conclusions of your study

% Kent Beck's sentences: The first states the problem. The second states why the problem is a problem. The third is my startling sentence. The fourth states the implication of my startling sentence.

\end{abstract}

\section{Introdução} % why

% why you have investigated the question
% 
% how it relates to earlier research that has been done in the field
% 
% 1. Open with two or three sentences placing your study subject in context
% 2. Follow with a description of the problem and its history, including previous research
% 3. Describe how your work addresses a gap in existing knowledge or ability (here's where you'll state why you've undertaken this study). 
% 4. State what information your article will address. 

Recuperação de arquitetura de \emph{software} é o ato de extrair aspectos da arquitetura de um sistema através de artefatos como código-fonte. Muitos esforços têm se concentrado no particionamento de sistemas em módulos arquiteturais --- grupos coesos de entidades de código-fonte (classes ou funções) --- através de algoritmos de agrupamento (\emph{clustering}). Não há consenso, no entanto, sobre quais algoritmos de agrupamento são mais adequados para a tarefa de recuperação de módulos arquiteturais.

Uma formas de avaliar um algoritmo de agrupamento consiste em aplicá-lo a um sistema cuja organização do código-fonte em módulos seja conhecida e então comparar os módulos do sistema com os módulos encontrados pelo algoritmo através de uma medida de distância entre particionamentos. Infelizmente é difícil encontrar sistemas documentados nesse nível de detalhe, e por isso os estudos experimentais realizados são superficiais. Alguns estudos revelam que a avaliação de um algoritmo varia bastante de sistema para sistema. Devido ao pequeno tamanho das amostras analisadas, no entanto, não existe uma explicação que permita que se determine a priori se um algoritmo fornece bons resultados para um sistema.

%Alguns experimentos revelam que o algoritmo mais adequado para um sistema pode ter um desempenho medíocre quando aplicado a outro sistema mas, devido às amostras pequenas, não foi encontrada uma explicação para essa variação.
% consideram amostras pequenas

%OS ESTUDOS FEITOS ASSIM NÃO SÃO CONTUNDENTES, OBTÊM RESULTADOS DIFERENTES PARA SISTEMAS DIFERENTES E NÃO TÊM NENHUMA PISTA SOBRE O QUE FAZ UM ALGORITMO SER BOM EM UM SISTEMA E RUIM EM OUTRO.

Propomos uma abordagem de avaliação complementar, baseada na análise de sistemas de software sintéticos. Esses sistemas são gerados por computador a partir de modelos parametrizáveis e obedecem a estruturas modulares conhecidas. Com essa abordagem é possível avaliar algoritmos de agrupamento com amostras arbitrariamente grandes de sistemas arbitrariamente complexos e, sobretudo, estudar como o desempenho dos algoritmos é afetado por parâmetros que definem os sistemas sintéticos.

Neste artigo apresentamos um modelo para a geração de sistemas sintéticos e avaliamos o realismo desse modelo, isto é, a similaridade entre os sistemas sintéticos e sistemas reais. Para fins de comparação, essa mesma análise é realizada sobre modelos genéricos disponíveis na literatura sobre redes complexas.

Na próxima seção.... na seção x.... por fim, .....

\section{Fundamentação Teórica}

Para recuperar os módulos de um sistema é suficiente considerar as suas classes e os relacionamentos de dependência entre elas --- uma rede de dependências entre classes. Essas redes podem ser extraídas automaticamente a partir da análise estática do código-fonte ou do código objeto do sistema que se deseja estudar.

Pesquisas recentes na teoria das redes complexas encontraram características comuns a redes que representam objetos de diversos domínios (sociologia, biologia, linguística, tecnologia etc.), incluindo as redes de dependências entre classes. A partir daí foram criados diversos modelos que procuram explicar como essas redes são formadas.

%Neste estudo foram avaliados três modelos de geração de redes complexas: o modelo de configuração, o modelo de Bollobás \cite{Bollobas2003}, o modelo de Lancichinetti, Fortunato e Radicchi \cite{Lancichinetti2008} e um novo modelo, baseado no modelo de Bollobás. Os dois últimos modelos geram redes com uma estrutura de módulos embutida.

\subsection{Modelos de Geração de Redes Complexas}

Bollobas: pensando na Web. Não tem estrutura de módulos embutida. Parâmetros são probabilidades.

O modelo de Lancichinetti não foi feito baseado em nenhum domínio em particular. Parâmetros são métricas da rede que se quer obter. Não-orientado.

O modelo X...

\section{O modelo novo}

Valorizar o modelo novo. Em relação a Bollobas, ele tem módulos embutidos. Em relação a Lancichinetti, pode especificar a arquitetura, mixing é variável, o grafo da arquitetura não é necessariamente completo.

\section{Experimento} % how

Realizamos um experimento a fim de avaliar os modelos de redes de acordo com a sua capacidade de gerar redes semelhantes a redes de sistemas reais. Para isso consideramos dois sistemas, o jogo VilloNanny 2.2.4 e o programa IRPF 2009, e ajustamos os parâmetros dos modelos de acordo com métricas extraídas desses sistemas. O experimento foi dividido em cinco etapas: extração das redes dos sistemas (redes reais), análise das redes reais, sintonia dos parâmetros dos modelos, geração de redes sintéticas e comparação entre redes sintéticas e as redes reais correspondentes. 

%Neste estudo consideramos dois sistemas de software reais e três modelos de geração de redes complexas.

\subsection{Extração}

Os sistemas analisados são implementados na linguagem Java e foram distribuídos em diversos arquivos JAR, cada arquivo contendo várias classes. Alguns arquivos JAR contêm classes específicas de um sistema, mas muitos deles são bibliotecas; consideramos que as bibliotecas que um sistema usa são parte do sistema, e cada arquivo JAR corresponde a um módulo arquitetural. Essa é uma aproximação razoável, uma vez que arquivos JAR distintos são, em geral, desenvolvidos por equipes diferentes e distribuídos independentemente. 
%(Naturalmente, cada um desses módulos pode ser decomposto em submódulos, formando uma hierarquia de módulos XXX)

A ferramenta DepFind\footnote{\url{http://depfind.sourceforge.net/}} foi usada para extrair, através da análise estática dos arquivos JAR, a rede de dependências entre as classes. A organização em módulos foi extraída a partir da enumeração das classes contidas em cada arquivo JAR.

\subsection{Análise de sistemas reais}

O grau de um vértice é o número de arestas que estão ligadas a ele. Baseado em pesquisas anteriores, consideramos que a distribuição estatística dos graus dos vértices segue aproximadamente uma lei de potência, $P(k) ~ k^{-\gamma}$, onde $P(k)$ é a probabilidade de um vértice escolhido possuir grau $k$ e $\gamma$ é o expoente da distribuição. Usamos esse mesmo tipo de distribuição para modelar a distribuição dos tamanhos dos módulos.


Para cada rede foram coletadas diversas métricas da teoria dos grafos e da teoria das redes complexas:

\begin{itemize}
\item número de vértices - ...
\item número de arestas - ...
\item número de arestas externas - número de arestas que ligam vértices em módulos distintos.

\item grau médio - ...
\item grau máximo - ...
\item expoente da distribuição de graus - ...

\item número de módulos
\item tamanho do menor módulo
\item tamanho do maior módulo
\item expoente da distribuição dos tamanhos dos módulos

%\item coeficiente de clustering
\end{itemize}

Os expoentes das distribuições de graus e de tamanhos dos módulos foram estimados através da técnica de máxima verossimilhança \cite{Clauset2007} através de uma implementação disponível disponível na Internet\footnote{\url{http://www.santafe.edu/~aaronc/powerlaws/}}. 
%No caso da distribuição dos tamanhos dos módulos fixamos xmin = 1, pois o número de módulos é pequeno...

Extraímos ainda a rede de dependências entre MÓDULOS...

\subsection{Sintonia dos parâmetros dos modelos}

Dado um sistema e um modelo, os parâmetros do modelo foram escolhidos de forma a gerar redes cujas métricas fossem próximas às metricas da rede do sistema.

No modelo de Lancichinetti os parâmetros correspondem às métricas.

No outro modelo isso foi feito na tentativa e erro (oops, experimentalmente).

Distribuição de graus foi usada para todos os modelos.

Modelo de Lancichinetti tem os seguintes parâmetros.

No modelo de Bollobás os parâmetros não correspondem a métricas da rede resultante, e por isso foi preciso sintonizar os parâmetros de forma experimental (correspondência analítica existe, mas não consegui usar).

\subsection{Geração de sistemas sintéticos}

Foram gerados 10 redes para cada modelo. Por que 10?

\subsection{Comparação com os sistemas reais}

Usamos a métrica de distância entre redes definida por \cite{Andrade2008}, implementação de Charles. Essa distância leva em consideração aspectos locais das redes. Comparar apenas os parâmetros globais não é tão bom porque não diferencia entre modelos, já que existem vários modelos que, como se sabe, geram power law.

% talvez usar um ks.test (visualmente: qqplot) dos graus da rede sintética vs. graus da rede real (e o mesmo com outros parâmetros) [ver também AIC no pacote stats]
% talvez usar library(igraph) g = read.graph("..."), graph.motif(g) e comparar a frequencia de motifs através de ks.test. Desenho do motif: graph.isocreate(3, i), i entre 0 e 15

Consideramos para cada modelo a média entre as distâncias de cada rede gerada pelo modelo.

%particular techniques used and why, if relevant
%modifications of any techniques; be sure to describe the modification
%assumptions underlying the study 
%statistical methods, including software programs 

\section{Resultados} % what was found

TABELA 1: sistemas analisados. Nome, versão, métricas (tamanho, número de módulos, ....)

TABELA 2: métricas das redes sintéticas.

TABELA 3 (ou GRÁFICO): distâncias

%  * present results clearly and logically
%  * avoid excess verbiage
%  * consider providing a one-sentence summary at the beginning of each paragraph if you think it will help your reader understand your data 

\section{Discussão} % why it's significant

% Recapitulando o que este trabalho fez:

% Produção de um modelo, baseado em um modelo existente, de geração de redes de software com estrutura de módulos embutida.

% Comparação desse modelo com um modelo presente na literatura usando como critério a semelhança com redes de software.

% Análise desse modelo modelos de geração de redes com estrutura de módulos embutida, e da semelhança dessas redes com redes de software.

% -----

O quão bem o modelo funciona, vantagens e desvantagens em relação a outras abordagens (complementares).

Especulação sobre o papel da modelagem estatística na engenharia de software.

Focar na hipótese: redes sintéticas com parâmetros ajustáveis dão insights sobre as ferramentas de engenharia reversa / evolução de software.
% redes sintéticos são uma boa aproximação de redes reais

%how useful this technique is: how well did it work, what are the benefits and drawbacks, etc

%This section centers on speculation

%Focus your discussion around a particular question or hypothesis

Trabalhos futuros: explorar métricas de arquitetura, avaliar algoritmos de clustering, considerar outros modelos.
% considerar o uso de arestas orientadas e pesos das arestas .

%\bibliographystyle{apalike}
\bibliographystyle{abbrv}
\bibliography{complex-networks,rodrigo-mestrado}

\end{document}








%arbitrariamente complexos

%Propomos sistemas de software gerados por computador, COM ESTRUTURA DE MÓDULOS EMBUTIDA. VANTAGENS: É POSSÍVEL AJUSTAR PARÂMETROS DOS SISTEMAS GERADOS E ASSIM GANHAR INSIGHT SOBRE OS PARÂMETROS QUE INFLUENCIAM A ACURÁCIA DE UM ALGORITMO. EM PARTICULAR, É POSSÍVEL CONTROLAR O TAMANHO DO SOFTWARE GERADO E, ASSIM, GERAR SISTEMAS GRANDES, MAIS PARECIDOS COM OS QUE SERIAM ANALISADOS PELAS TÉCNICAS EM UM CENÁRIO REAL.

%embora existam alguns trabalhos avaliando algoritmos de recuperação de arquitetura, os resultados experimentais não dão pistas sobre por que os algoritmos são bons em uns critérios e ruins em outros, quais são as coisas que influenciam o desempenho do algoritmo.

%Neste estudo nos concentraremos em sistemas orientados a objeto, para simplificar, mas os conceitos provavelmente podem ser aplicados a outros paradigmas como procedimental ou funcional. 
%Muitas técnicas de recuperação de arquitetura analisam uma representação abstrata de sistemas de software, as redes de dependências entre classes. Nessas redes, os vértices representam classes e existe uma aresta do vértice A para o vértice B se a classe A depende da classe B para funcionar corretamente. Essa dependência pode ser resultado diversos tipos de interação entre as classes: A estende B, um método de A chama um método de B etc. A extração da rede de um sistema de software se dá através da análise estática de seu código-fonte ou do código objeto.

