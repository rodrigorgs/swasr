% This file was created with JabRef 2.4.2.
% Encoding: Cp1252

@INPROCEEDINGS{Andreopoulos2005,
  author = {Andreopoulos, B. and An, Aijun and Tzerpos, V. and Wang, Xiaogang},
  title = {Multiple layer clustering of large software systems},
  booktitle = {Proc. th Working Conference on Reverse Engineering},
  year = {2005},
  pages = {10 pp.--},
  abstract = {Software clustering algorithms presented in the literature rarely
	incorporate in the clustering process dynamic information, such as
	the number of function invocations during runtime. Moreover, the
	structure of a software system is often multi-layered, while existing
	clustering algorithms often create flat system decompositions. This
	paper presents a software clustering algorithm called MULICsoft that
	incorporates in the clustering process both static and dynamic information.
	MULICsoft produces layered clusters with the core elements of each
	cluster assigned to the top layer. We present experimental results
	of applying MULICsoft to a large open-source system. Comparison with
	existing software clustering algorithms indicates that MULICsoft
	is able to produce decompositions that are close to those created
	by system experts.},
  doi = {10.1109/WCRE.2005.24},
  file = {Andreopoulos, Tzerpos et al - Multiple Layer Clustering of Large Software
	Systems (2005).pdf:papers/Andreopoulos, Tzerpos et al - Multiple
	Layer Clustering of Large Software Systems (2005).pdf:PDF},
  issn = {1095-1350},
  keywords = {public domain software, software engineering, MULICsoft, dynamic information
	clustering, flat system decompositions, function invocations, open-source
	system, software clustering, static information clustering},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Andritsos2005,
  author = {Andritsos, P. and Tzerpos, V.},
  title = {Information-theoretic software clustering},
  journal = {IEEE Transactions on Software Engineering},
  year = {2005},
  volume = {31},
  pages = {150--165},
  number = {2},
  note = {LIMBO},
  __markedentry = {[rodrigo]},
  abstract = {The majority of the algorithms in the software clustering literature
	utilize structural information to decompose large software systems.
	Approaches using other attributes, such as file names or ownership
	information, have also demonstrated merit. At the same time, existing
	algorithms commonly deem all attributes of the software artifacts
	being clustered as equally important, a rather simplistic assumption.
	Moreover, no method that can assess the usefulness of a particular
	attribute for clustering purposes has been presented in the literature.
	In this paper, we present an approach that applies information theoretic
	techniques in the context of software clustering. Our approach allows
	for weighting schemes that reflect the importance of various attributes
	to be applied. We introduce LIMBO, a scalable hierarchical clustering
	algorithm based on the minimization of information loss when clustering
	a software system. We also present a method that can assess the usefulness
	of any nonstructural attribute in a software clustering context.
	We applied LIMBO to three large software systems in a number of experiments.
	The results indicate that this approach produces clusterings that
	come close to decompositions prepared by system experts. Experimental
	results were also used to validate our usefulness assessment method.
	Finally, we experimented with well-established weighting schemes
	from information retrieval, Web search, and data clustering. We report
	results as to which weighting schemes show merit in the decomposition
	of software systems.},
  doi = {10.1109/TSE.2005.25},
  issn = {0098-5589},
  keywords = {information retrieval, pattern clustering, reverse engineering, software
	architecture, software maintenance, software metrics, systems re-engineering,
	Web search, data clustering, information retrieval, software clustering,
	software system, Index Terms- Reverse engineering, architecture reconstruction,
	clustering, information theory., reengineering},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Andritsos2003,
  author = {Andritsos, P. and Tzerpos, V. },
  title = {Software clustering based on information loss minimization},
  booktitle = {Proc. 10th Working Conference on Reverse Engineering WCRE 2003},
  year = {2003},
  pages = {334--344},
  issn = {1095-1350},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@ARTICLE{Anquetil1997,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  title = {File Clustering Using Naming Conventions for Legacy Systems},
  year = {1997},
  file = {File Clustering Using Naming Conventions for Legacy Systems.pdf:papers/File
	Clustering Using Naming Conventions for Legacy Systems.pdf:PDF;File
	Clustering Using Naming Conventions for Legacy Systems.pdf:papers/File
	Clustering Using Naming Conventions for Legacy Systems.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Anquetil2003,
  author = {Anquetil, N. and Lethbridge, T. C.},
  title = {Comparative study of clustering algorithms and abstract representations
	for software remodularisation},
  journal = {IEE Proceedings -Software},
  year = {2003},
  volume = {150},
  pages = {185--201},
  number = {3},
  abstract = {As valuable software systems become older, reverse engineering becomes
	increasingly important to companies that have to maintain the code.
	Clustering is a key activity in reverse engineering that is used
	to discover improved designs of systems or to extract significant
	concepts from code. Clustering is an old, highly sophisticated, activity
	which offers many methods to meet different needs. The various methods
	have been well documented in the past; however, conclusions from
	general clustering literature may not apply entirely to the reverse
	engineering domain. In the paper, the authors study three decisions
	that need to be made when clustering: the choice of (i) abstract
	descriptions of the entities to be clustered, (ii) metrics to compute
	coupling between the entities, and (iii) clustering algorithms. For
	each decision, our objective is to understand which choices are best
	when performing software remodularisation. The experiments were conducted
	on three public domain systems (gcc, Linux and Mosaic) and a real
	world legacy system (2 million LOC). Among other things, the authors
	confirm the importance of a proper description scheme for the entities
	being clustered, list a few effective coupling metrics and characterise
	the quality of different clustering algorithms. They also propose
	description schemes not directly based on the source code, and advocate
	better formal evaluation methods for the clustering results.},
  doi = {10.1049/ip-sen:20030581},
  issn = {1462-5970},
  keywords = {reverse engineering, software engineering, abstract descriptions,
	clustering, formal evaluation methods, public domain systems, real
	world legacy system, reverse engineering, software remodularisation,
	valuable software systems},
  owner = {roden},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Anquetil1999,
  author = {Anquetil, N. and Lethbridge, T. C.},
  title = {Experiments with clustering as a software remodularization method},
  booktitle = {Proc. Sixth Working Conference on Reverse Engineering},
  year = {1999},
  pages = {235--255},
  note = {Precision, Recall},
  abstract = {As valuable software systems get old, reverse engineering becomes
	more and more important to the companies that have to maintain the
	code. Clustering is a key activity in reverse engineering to discover
	a better design of the systems or to extract significant concepts
	from the code. Clustering is an old activity, highly sophisticated,
	offering many methods to answer different needs. Although these methods
	have been well documented in the past, these discussions may not
	apply entirely to the reverse engineering domain. We study some clustering
	algorithms and other parameters to establish whether and why they
	could be used for software remodularization. We study three aspects
	of the clustering activity: abstract descriptions chosen for the
	entities to cluster; metrics computing coupling between the entities;
	and clustering algorithms. The experiments were conducted on three
	public domain systems (gcc, Linux and Mosaic) and a real world legacy
	system (2 million LOC). Among other things, we confirm the importance
	of a proper description scheme of the entities being clustered, we
	list a few good coupling metrics to use and characterize the quality
	of different clustering algorithms. We also propose novel description
	schemes not directly based on the source code and we advocate better
	formal evaluation methods for the clustering results},
  doi = {10.1109/WCRE.1999.806964},
  file = {Experiments with Clustering as a Software Remodularization Method.pdf:papers/Experiments
	with Clustering as a Software Remodularization Method.pdf:PDF},
  keywords = {reverse engineering, software maintenance, software metrics, Linux,
	Mosaic, abstract descriptions, clustering activity, clustering algorithms,
	coupling metrics, description scheme, description schemes, formal
	evaluation methods, gcc, metrics, public domain systems, real world
	legacy system, reverse engineering domain, software remodularization,
	software remodularization method, source code, valuable software
	systems},
  owner = {roden},
  timestamp = {2008.10.10}
}

@MISC{Bowman1998,
  author = {Bowman and Holt},
  title = {Software Architecture Recovery Using Conway's Law},
  year = {1998},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@MISC{Bowman1999,
  author = {Bowman, I T},
  title = {Architecture Recovery for Object Oriented Systems},
  year = {1999},
  note = {Nao consegui achar o texto completo.},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@INPROCEEDINGS{Chikofsky2005,
  author = {Chikofsky, E. },
  title = {On the Meeting of Software Architecture and Reverse Engineering},
  booktitle = {Proc. 5th Working IEEE/IFIP Conference on Software Architecture WICSA
	2005},
  year = {2005},
  pages = {17--24},
  abstract = {This year, the 12th Working Conference on Reverse Engineering (WCRE)
	is meeting in conjunction with the 5th IEEE/IFIP Working Conference
	on Software Architecture (WICSA) in Mellon University. However, that
	linking phrase "in conjunction with" does not do justice to the vision,
	discussions, creativity, and effort that have brought us here.},
  doi = {10.1109/WICSA.2005.48},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@MISC{Czibula2007,
  author = {Czibula and Serban},
  title = {Hierarchical Clustering for Software Systems Restructuring},
  year = {2007},
  file = {Czibula, Serban - Hierarchical Clustering for Software Systems Restructuring
	(2007).pdf:papers/Czibula, Serban - Hierarchical Clustering for Software
	Systems Restructuring (2007).pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Ding2001,
  author = {Ding, Lei and Medvidovic, N. },
  title = {Focus: a light-weight, incremental approach to software architecture
	recovery and evolution},
  booktitle = {Proc. Working IEEE/IFIP Conference on Software Architecture},
  year = {2001},
  pages = {191--200},
  note = {OO Recovery},
  abstract = {During the past decade (1991-2001), object-orientation (OO) has become
	the dominant software development methodology, accompanied by a number
	of modeling notations, programming languages, and development environments.
	OO applications of today are increasingly complex and user driven.
	They are also developed more rapidly and evolved more frequently
	than was the case with software systems of the past. All of these
	factors contribute to a plethora of potential problems when maintaining
	and evolving an OO application. These problems are caused by architectural
	erosion, where the initial architecture of an application is (arbitrarily)
	modified to the point where its key properties no longer hold. We
	propose an approach, called Focus, whose goal is to enable effective
	evolution of such an application with minimal effort, by recovering
	its architecture and using it as the basis of evolution. Focus allows
	engineers to direct their primary attention to the part of the system
	that is directly impacted by the desired change; subsequent changes
	will incrementally uncover additional parts of the system's architecture.
	We have applied Focus to four off-the-shelf applications to date.
	We discuss its key strengths and point out several open issues that
	will frame our future work},
  doi = {10.1109/WICSA.2001.948429},
  keywords = {graphical user interfaces, object-oriented programming, software architecture,
	software prototyping, system recovery, Focus, GUI, OO application
	evolution, OO architecture recovery, architectural erosion, light-weight
	incremental approach, modeling notations, object-orientation, off-the-shelf
	applications, software architecture evolution, software architecture
	recovery, software development methodology},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@INPROCEEDINGS{Doval1999,
  author = {Doval, D. and Mancoridis, S. and Mitchell, B. S.},
  title = {Automatic clustering of software systems using a genetic algorithm},
  booktitle = {Proc. Software Technology and Engineering Practice STEP '99},
  year = {1999},
  pages = {73--81},
  abstract = {Large software systems tend to have a rich and complex structure.
	Designers typically depict the structure of software systems as one
	or more directed graphs. For example, a directed graph can be used
	to describe the modules (or classes) of a system and their static
	interrelationships using nodes and directed edges, respectively.
	We call such graphs &ldquo;module dependency graphs&rdquo; (MDGs).
	MDGs can be large and complex graphs. One way of making them more
	accessible is to partition them, separating their nodes (i.e. modules)
	into clusters (i.e. subsystems). In this paper, we describe a technique
	for finding &ldquo;good&rdquo; MDG partitions. Good partitions feature
	relatively independent subsystems that contain modules which are
	highly interdependent. Our technique treats finding a good partition
	as an optimization problem, and uses a genetic algorithm (GA) to
	search the extraordinarily large solution space of all possible MDG
	partitions. The effectiveness of our technique is demonstrated by
	applying it to a medium-sized software system},
  doi = {10.1109/STEP.1999.798481},
  keywords = {directed graphs, genetic algorithms, reverse engineering, search problems,
	software engineering, subroutines, automatic clustering, directed
	edges, directed graphs, genetic algorithm, graph node clusters, graph
	partitioning, independent subsystems, interdependent modules, large
	software systems, medium-sized software system, module dependency
	graphs, module subsystems, optimization, reverse engineering, solution
	space searching, static interrelationships},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Duenas1998,
  author = {Duenas, J. C. and Lopes de Oliveira, W. and de la Puente, J. A.},
  title = {Architecture recovery for software evolution},
  booktitle = {Proc. Second Euromicro Conference on Software Maintenance and Reengineering},
  year = {1998},
  pages = {113--119},
  note = {Spring layout pode ser usado para clustering. (citado por Trifu2001)},
  abstract = {The maintenance is a costly activity in the life cycle of software-intensive
	systems, especially when they must as adapted to evolving requirements,
	which is more likely as the size of the system grows. Software architecture
	is a novel approach to the development of such systems, that guides
	the process focusing the architects' attention on the structure of
	the system being built, thus allowing a controlled evolution. This
	approach is applied for large systems or families of products with
	a long evolution path, and is usually performed once a successful
	system has been built, so in fact its application requires recovery
	techniques in order to obtain and incorporate as much information
	as possible. Furthermore, since these systems tend to be large, automatic
	aids must be used by engineers in the recovery tasks to do cost effective
	work. The article describes the experience of architectural recovery
	of a large telecommunication system, presents the characteristics
	of the architectural recovery process applied, reviews some of the
	available recovery techniques and organises their application for
	software architecture recovery},
  doi = {10.1109/CSMR.1998.665766},
  keywords = {automatic programming, software maintenance, system recovery, systems
	analysis, telecommunication computing, architectural recovery, architectural
	recovery process, automatic aids, cost effective work, evolution
	path, evolving requirements, large systems, large telecommunication
	system, recovery tasks, recovery techniques, software architecture,
	software architecture recovery, software evolution, software maintenance,
	software-intensive systems},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@MISC{Eixelsberger,
  author = {Eixelsberger, Klosch},
  title = {A Framework for Software Architecture Recovery},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@PHDTHESIS{Hatch2004,
  author = {Hatch},
  title = {Software Architecture Visualisation},
  school = {Univ. of Durham},
  year = {2004},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Huynh2008,
  author = {Sunny Huynh and Yuanfang Cai and Yuanyuan Song and Kevin Sullivan},
  title = {Automatic modularity conformance checking},
  booktitle = {ICSE '08: Proceedings of the 30th international conference on Software
	engineering},
  year = {2008},
  pages = {411--420},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {According to Parnas's information hiding principle and Baldwin and
	Clark's design rule theory, the key step to decomposing a system
	into modules is to determine the design rules (or in Parnas's terms,
	interfaces) that decouple otherwise coupled design decisions and
	to hide decisions that are likely to change in independent modules.
	Given a modular design, it is often difficult to determine whether
	and how its implementation realizes the designed modularity. Manually
	comparing code with abstract design is tedious and error-prone. We
	present an automated approach to check the conformance of implemented
	modularity to designed modularity, using esign structure matricesas
	a uniform representation for both. Our experiments suggest that our
	approach has the potential to manifest the decoupling effects of
	esign rulesin code, and to detect modularity deviation caused by
	implementation faults. We also show that design and implementation
	models together provide a comprehensive view of modular structure
	that makes certain implicit dependencies within code explicit.},
  doi = {http://doi.acm.org/10.1145/1368088.1368144},
  file = {Cai et al - Automatic Modularity Conformance Checking.pdf:papers/Cai
	et al - Automatic Modularity Conformance Checking.pdf:PDF},
  isbn = {978-1-60558-079-1},
  location = {Leipzig, Germany},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Koschke2000a,
  author = {Koschke},
  title = {Atomic Architectural Component Recovery for Program Understanding
	and Evolution},
  school = {Univ. Stuttgart},
  year = {2000},
  file = {Koschke - [Thesis] Atomic Architectural Component Recovery for Program
	Understanding and Evolution.pdf:papers/Koschke - [Thesis] Atomic
	Architectural Component Recovery for Program Understanding and Evolution.pdf:PDF;Koschke
	- [Thesis] Atomic Architectural Component Recovery for Program Understanding
	and Evolution.pdf:papers/Koschke - [Thesis] Atomic Architectural
	Component Recovery for Program Understanding and Evolution.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Koschke2000,
  author = {Koschke, R. and Eisenbarth, T.},
  title = {A framework for experimental evaluation of clustering techniques},
  booktitle = {Proc. 8th International Workshop on Program Comprehension IWPC 2000},
  year = {2000},
  pages = {201--210},
  note = {Kosche-Eisenbarth (KE) measure},
  __markedentry = {[rodrigo]},
  abstract = {Experimental evaluation of clustering techniques for component recovery
	is necessary in order to analyze their strengths and weaknesses in
	comparison to other techniques. For comparable evaluations of automatic
	clustering techniques, a common reference corpus of freely available
	systems is needed for which the actual components are known. The
	reference corpus is used to measure recall and precision of automatic
	techniques. For this measurement, a standard scheme for comparing
	the components recovered by a clustering technique to components
	in the reference corpus is required. This paper describes both the
	process of setting up reference corpora and ways of measuring recall
	and precision of automatic clustering techniques. For methods with
	human intervention, controlled experiments should be conducted. This
	paper additionally proposes a controlled experiment as a standard
	for evaluating manual and semi-automatic component recovery methods
	that can be conducted cost-effectively},
  doi = {10.1109/WPC.2000.852494},
  file = {Koschke, Eisenbarth - [KE] A framework for experimental evaluation
	of clustering techniques.pdf:papers/Koschke, Eisenbarth - [KE] A
	framework for experimental evaluation of clustering techniques.pdf:PDF;Koschke,
	Eisenbarth - [KE] A framework for experimental evaluation of clustering
	techniques.pdf:papers/Koschke, Eisenbarth - [KE] A framework for
	experimental evaluation of clustering techniques.pdf:PDF},
  keywords = {reverse engineering, software reusability, clustering techniques,
	common reference corpus, cost-effective, experimental evaluation,
	program component recovery, program understanding},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Krikhaar1999,
  author = {Krikhaar},
  title = {Software Architecture Reconstruction},
  school = {Univ. of Amsterdam},
  year = {1999},
  note = {SARTool. Viewpoints, logic.},
  file = {Jha et al - A Comparison of Four Software Architecture Reconstruction
	Toolkits.pdf:papers/Jha et al - A Comparison of Four Software Architecture
	Reconstruction Toolkits.pdf:PDF;Pollet, Ducasse et al - Towards A
	Process-Oriented Software Architecture Reconstruction Taxonomy.pdf:papers/Pollet,
	Ducasse et al - Towards A Process-Oriented Software Architecture
	Reconstruction Taxonomy.pdf:PDF;Jha et al - A Comparison of Four
	Software Architecture Reconstruction Toolkits.pdf:papers/Jha et al
	- A Comparison of Four Software Architecture Reconstruction Toolkits.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Kuhn2005,
  author = {Kuhn, A. and Ducasse, S. and Girba, T.},
  title = {Enriching reverse engineering with semantic clustering},
  booktitle = {Proc. th Working Conference on Reverse Engineering},
  year = {2005},
  pages = {10 pp.--},
  abstract = {Understanding a software system by just analyzing the structure of
	the system reveals only half of the picture, since the structure
	tells us only how the code is working but not what the code is about.
	What the code is about can be found in the semantics of the source
	code: names of identifiers, comments etc. In this paper, we analyze
	how these terms are spread over the source artifacts using latent
	semantic indexing, an information retrieval technique. We use the
	assumption that parts of the system that use similar terms are related.
	We cluster artifacts that use similar terms, and we reveal the most
	relevant terms for the computed clusters. Our approach works at the
	level of the source code which makes it language independent. Nevertheless,
	we correlated the semantics with structural information and we applied
	it at different levels of abstraction (e.g. classes, methods). We
	applied our approach on three large case studies and we report the
	results we obtained.},
  doi = {10.1109/WCRE.2005.16},
  file = {Kuhn, Ducasse, Girba - Enriching reverse engineering with semantic
	clustering.pdf:papers/Kuhn, Ducasse, Girba - Enriching reverse engineering
	with semantic clustering.pdf:PDF;Kuhn, Ducasse, Girba - Enriching
	reverse engineering with semantic clustering.pdf:papers/Kuhn, Ducasse,
	Girba - Enriching reverse engineering with semantic clustering.pdf:PDF},
  issn = {1095-1350},
  keywords = {formal specification, indexing, information retrieval, program diagnostics,
	programming language semantics, reverse engineering, structured programming,
	artifacts clustering, information retrieval, latent semantic indexing,
	reverse engineering, semantic clustering, software system, source
	code semantic, system structure, clustering, concept location, reverse
	engineering, semantic analysis},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Lakhotia1995,
  author = {Lakhotia, A. and Gravley, J. M. },
  title = {Toward experimental evaluation of subsystem classification recovery
	techniques},
  booktitle = {Proc. 2nd Working Conference on Reverse Engineering},
  year = {1995},
  pages = {262--269},
  note = {Measure of Congruence},
  abstract = {Several reverse engineering techniques classify software system components
	into subsystems. These techniques are designed to discover such classifications
	when the classifications are unknown. The techniques are rested and
	evaluated, however, by matching the classifications they recover
	against expected classifications. Several such techniques may be
	compared by experimentally evaluating their performance on the same
	set of software systems. Two things are needed to ensure experiment
	repeatability: a set of &ldquo;real-world&rdquo; software systems
	whose expected subsystem classifications are known; and an objective
	criterion to quantitatively determine the similarity of subsystem
	classifications. This paper contributes to both needs by identifying
	a set of widely used and easily accessible software systems whose
	modular decomposition either is documented or can be easily inferred
	from their design philosophy, and by presenting a measure to quantitatively
	determine the congruence between hierarchical subsystem classifications},
  doi = {10.1109/WCRE.1995.514714},
  file = {Lakhotia, Gravley - [CongruenceMeasure] Toward Experimental Evaluation
	of Subsystem Classification Recovery Techniques.pdf:papers/Lakhotia,
	Gravley - [CongruenceMeasure] Toward Experimental Evaluation of Subsystem
	Classification Recovery Techniques.pdf:PDF},
  keywords = {reverse engineering, software performance evaluation, system documentation,
	design philosophy, experiment repeatability, hierarchical subsystem
	classifications, modular decomposition, performance evaluation, reverse
	engineering, subsystem classification recovery, subsystem classifications},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Landi1992,
  author = {William Landi},
  title = {Undecidability of Static Analysis},
  journal = {ACM Letters on Programming Languages and Systems},
  year = {1992},
  volume = {1},
  pages = {323--337}
}

@INPROCEEDINGS{Li2005,
  author = {Li, Qingshan},
  title = {Dynamic Model Design Recovery and Architecture Abstraction of Object
	Oriented Software},
  booktitle = {Proc. Ninth European Conference on Software Maintenance and Reengineering
	CSMR 2005},
  year = {2005},
  pages = {284--287},
  abstract = {The paper gives an overview of a Ph.D. thesis and describes the main
	contents of the thesis. The thesis makes research on reverse engineering
	of object-oriented software at source codes level. According to the
	dynamic property of object-oriented software system, a group of models,
	mechanisms and algorithms that can be used to extract dynamic information
	and abstract high-level models of such systems are provided in the
	thesis. A group of systematic experiments are also conducted in the
	thesis so as to verify the correctness, validity and other related
	performance of these dynamic model design recovery and architecture
	abstraction algorithms.},
  doi = {10.1109/CSMR.2005.26},
  issn = {1534-5351},
  keywords = {data structures, formal verification, object-oriented programming,
	reverse engineering, software architecture, architecture abstraction,
	design recovery, dynamic information, dynamic model, object oriented
	software, reverse engineering, Architecture Abstraction, Design Recovery,
	Object Orientation, Program Comprehension, Reverse Engineering},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@ARTICLE{Lindvall2008,
  author = {Lindvall, M. and Muthig, D. },
  title = {Bridging the Software Architecture Gap},
  journal = {Computer},
  year = {2008},
  volume = {41},
  pages = {98--101},
  number = {6},
  abstract = {There's a growing gap between the state of the art and the state of
	the practice in software architecture. The state of the art revolves
	around advanced architecture description and modeling languages,
	while in practice, the software architect - if there is one - has
	neither the power nor the tools to create a sound software architecture
	that is truly useful throughout the entire software life cycle. The
	SAVE tool helps developers align a system with the planned architecture.},
  doi = {10.1109/MC.2008.176},
  file = {Bridging the Software Architecture Gap.pdf:papers/Bridging the Software
	Architecture Gap.pdf:PDF;Bridging the Software Architecture Gap.pdf:papers/Bridging
	the Software Architecture Gap.pdf:PDF},
  issn = {0018-9162},
  keywords = {formal specification, software architecture, software prototyping,
	software tools, specification languages, SAVE tool, architecture
	description, modeling language, software architecture gap, software
	life cycle, software artchitecture, software development, visualization
	tools},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Mancoridis1996,
  author = {Mancoridis, S. and Holt, R. C.},
  title = {Recovering the structure of software systems using tube graph interconnection
	clustering},
  booktitle = {Proc. International Conference on Software Maintenance 1996},
  year = {1996},
  pages = {23--32},
  note = {Edge clustering},
  abstract = {An important product of the software design phase is the specification
	of the software structure at various levels of detail. Without reliable
	design documentation, significant software systems become less accessible
	to software engineers because structural information is buried in
	the intricate implementation source code. Reverse engineering techniques
	aim at recovering the structure of software systems, from the source
	code and mental models of developers, in order to make these systems
	more understandable to those maintaining them. Many reverse engineering
	techniques rely on creating a decomposition hierarchy by recursively
	clustering related software components (e.g., variables, procedures,
	classes, modules) into composite components (e.g., subsystems). Component
	clustering is necessary for managing complexity, and therefore is
	an important step in the reverse engineering process. We argue that
	the clustering of interconnections is also necessary during reverse
	engineering, We propose an approach, based on a formalism called
	tube graphs, to specifying system structure that considers both composite
	software components and composite interconnections between these
	components. We present efficient algorithms for software interconnection
	clustering, which nicely complement existing software component clustering
	algorithms},
  doi = {10.1109/ICSM.1996.564985},
  keywords = {formal specification, graph theory, reverse engineering, software
	maintenance, software reliability, component clustering, composite
	interconnections, composite software components, decomposition hierarchy,
	implementation source code, mental models, recursive clustering,
	related software components, reliable design documentation, reverse
	engineering techniques, software design phase, software engineers,
	software interconnection clustering, software structure specification,
	software systems, source code, structural information, structure
	recovery, system structure specification, tube graph interconnection
	clustering},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Mancoridis1998,
  author = {Mancoridis, S. and Mitchell, B. S. and Rorres, C. and Chen, Y. and
	Gansner, E. R.},
  title = {Using automatic clustering to produce high-level system organizations
	of source code},
  booktitle = {Proc. th International Workshop on Program Comprehension IWPC '98},
  year = {1998},
  pages = {45--52},
  note = {Bunch},
  __markedentry = {[rodrigo]},
  abstract = {We describe a collection of algorithms that we developed and implemented
	to facilitate the automatic recovery of the modular structure of
	a software system from its source code. We treat automatic modularization
	as an optimization problem. Our algorithms make use of traditional
	hill-climbing and genetic algorithms},
  doi = {10.1109/WPC.1998.693283},
  file = {Mancoridis, Mitchell et al - Using Automatic Clustering to Produce
	High-Level System Organizations of Source Code.pdf:papers/Mancoridis,
	Mitchell et al - Using Automatic Clustering to Produce High-Level
	System Organizations of Source Code.pdf:PDF},
  issn = {1092-8138},
  keywords = {genetic algorithms, graph theory, reverse engineering, software engineering,
	automatic clustering, automatic modularization, genetic algorithms,
	graph theory, high-level system organizations, hill-climbing algorithms,
	optimization problem, reverse engineering, software structure recovery,
	source code},
  owner = {roden},
  timestamp = {2008.10.10}
}

@ARTICLE{Maqbool2007,
  author = {Maqbool, O. and Babri, H. A.},
  title = {Hierarchical Clustering for Software Architecture Recovery},
  journal = IEEE_J_SE,
  year = {2007},
  volume = {33},
  pages = {759--780},
  number = {11},
  abstract = {Gaining an architectural level understanding of a software system
	is important for many reasons. When the description of a system's
	architecture does not exist, attempts must be made to recover it.
	In recent years, researchers have explored the use of clustering
	for recovering a software system's architecture, given only its source
	code. The main contributions of this paper are given as follows.
	First, we review hierarchical clustering research in the context
	of software architecture recovery and modularization. Second, to
	employ clustering meaningfully, it is necessary to understand the
	peculiarities of the software domain, as well as the behavior of
	clustering measures and algorithms in this domain. To this end, we
	provide a detailed analysis of the behavior of various similarity
	and distance measures that may be employed for software clustering.
	Third, we analyze the clustering process of various well-known clustering
	algorithms by using multiple criteria, and we show how arbitrary
	decisions taken by these algorithms during clustering affect the
	quality of their results. Finally, we present an analysis of two
	recently proposed clustering algorithms, revealing close similarities
	in their apparently different clustering approaches. Experiments
	on four legacy software systems provide insight into the behavior
	of well-known clustering algorithms and their characteristics in
	the software domain.},
  doi = {10.1109/TSE.2007.70732},
  file = {Maqbool, Babri - Hierarchical Clustering for Software Architecture
	Recovery (2007).pdf:papers/Maqbool, Babri - Hierarchical Clustering
	for Software Architecture Recovery (2007).pdf:PDF;Maqbool, Babri
	- Hierarchical Clustering for Software Architecture Recovery (2007).pdf:papers/Maqbool,
	Babri - Hierarchical Clustering for Software Architecture Recovery
	(2007).pdf:PDF},
  issn = {0098-5589},
  keywords = {software architecture, arbitrary decisions, architectural level understanding,
	clustering algorithms, hierarchical clustering research, software
	architecture recovery, software domain, software modularization,
	Restructuring, Software Engineering, and reengineering, arbitrary
	decisions, architecture recovery, hierarchical clustering, reverse
	engineering},
  owner = {roden},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Maqbool2005,
  author = {Maqbool, O. and Babri, H. A. },
  title = {Interpreting clustering results through cluster labeling},
  booktitle = {Proc. IEEE Symposium on Emerging Technologies},
  year = {2005},
  pages = {429--434},
  abstract = {Software architecture refers to the overall structure of a software
	system, and is defined by the components (sub-systems) within a software
	system and their interactions with one another. Quite often, there
	is little documentation describing a software system's architecture,
	especially in the case of legacy software systems. Thus techniques
	must be employed for recovering the architecture from the software's
	source code. Given the size and complexity of legacy systems, researchers
	have started exploring the use of automated techniques for architecture
	recovery. A technique that has shown promising results is clustering.
	Clusters that are obtained as a result of the clustering process
	represent sub-systems within a software system, but are nor easy
	to interpret until they are given appropriate names. In this paper,
	we present a cluster labeling scheme based on identifiers. As the
	clustering process proceeds, keywords are ranked using the inverse
	document frequency ranking scheme. Results of experiments conducted
	on a test system demonstrate that our labeling approach is effective.
	We also compare the clustering results of the complete algorithm
	and the weighted combined algorithm based on labels of the clusters
	produced by them during clustering.},
  doi = {10.1109/ICET.2005.1558920},
  file = {Maqbool, Babri - Interpreting Clustering Results through Cluster Labeling
	(2005).pdf:papers/Maqbool, Babri - Interpreting Clustering Results
	through Cluster Labeling (2005).pdf:PDF},
  keywords = {software architecture, software maintenance, system documentation,
	architecture recovery, cluster labeling, clustering process, documentation,
	identifiers, inverse document frequency ranking scheme, software
	architecture, source code, system, weighted combined algorithm},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Mendonca1999,
  author = {Mendonça, N},
  title = {Software Architecture Recovery for Distributed Systems},
  school = {Univ. of London},
  year = {1999},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@PHDTHESIS{Mitchell2002,
  author = {Mitchell, B. S.},
  title = {A Heuristic Search Approach to Solving the Software Clustering Problem},
  school = {Drexel University},
  year = {2002},
  note = {EdgeSim, MeCl},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Mitchell2001,
  author = {Mitchell, B. S. and Mancoridis, S.},
  title = {Comparing the decompositions produced by software clustering algorithms
	using similarity measurements},
  booktitle = {Proc. IEEE International Conference on Software Maintenance},
  year = {2001},
  pages = {744--753},
  note = {EdgeSim and MeCl},
  abstract = {Decomposing source code components and relations into subsystem clusters
	is an active area of research. Numerous clustering approaches have
	been proposed in the reverse engineering literature, each one using
	a different algorithm to identify subsystems. Since different clustering
	techniques may not produce identical results when applied to the
	same system, mechanisms that can measure the extent of these differences
	are needed. Some work to measure the similarity between decompositions
	has been done, but this work considers the assignment of source code
	components to clusters as the only criterion for similarity. We argue
	that better similarity measurements can be designed if the relations
	between the components are considered. The authors propose two similarity
	measurements that overcome certain problems in existing measurements.
	We also provide some suggestions on how to identify and deal with
	source code components that tend to contribute to poor similarity
	results. We conclude by presenting experimental results, and by highlighting
	some of the benefits of our similarity measurements},
  doi = {10.1109/ICSM.2001.972795},
  file = {Comparing the decompositions produced by software clustering algorithms
	using similarity measurements.pdf:papers/Comparing the decompositions
	produced by software clustering algorithms using similarity measurements.pdf:PDF;Comparing
	the decompositions produced by software clustering algorithms using
	similarity measurements.pdf:papers/Comparing the decompositions produced
	by software clustering algorithms using similarity measurements.pdf:PDF},
  keywords = {reverse engineering, software maintenance, software metrics, systems
	re-engineering, clustering approaches, clustering techniques, reverse
	engineering, similarity measurements, similarity results, software
	clustering algorithms, source code component decomposition, source
	code components, subsystem clusters},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Parnas1972,
  author = {Parnas,, D. L.},
  title = {On the criteria to be used in decomposing systems into modules},
  journal = {Commun. ACM},
  year = {1972},
  volume = {15},
  pages = {1053--1058},
  number = {12},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/361598.361623},
  issn = {0001-0782},
  publisher = {ACM}
}

@INPROCEEDINGS{Pollet2007,
  author = {Pollet, Damien and Ducasse, Stephane and Poyet, Loic and Alloui,
	Ilham and Cimpan, Sorana and Verjus, Herve},
  title = {Towards A Process-Oriented Software Architecture Reconstruction Taxonomy},
  booktitle = {Proc. 11th European Conference on Software Maintenance and Reengineering
	CSMR '07},
  year = {2007},
  pages = {137--148},
  abstract = {To maintain and understand large applications, it is crucial to know
	their architecture. The first problem is that unlike classes and
	packages, architecture is not explicitly represented in the code.
	The second problem is that successful applications evolve over time,
	so their architecture inevitably drifts. Reconstructing the architecture
	and checking whether it is still valid is therefore an important
	aid. While there is a plethora of approaches and techniques supporting
	architecture reconstruction, there is no comprehensive state of the
	art and it is often difficult to compare the approaches. This article
	presents a state of the art on software architecture reconstruction
	approaches},
  doi = {10.1109/CSMR.2007.50},
  file = {Pollet, Ducasse et al - Towards A Process-Oriented Software Architecture
	Reconstruction Taxonomy.pdf:papers/Pollet, Ducasse et al - Towards
	A Process-Oriented Software Architecture Reconstruction Taxonomy.pdf:PDF;Pollet,
	Ducasse et al - Towards A Process-Oriented Software Architecture
	Reconstruction Taxonomy.pdf:papers/Pollet, Ducasse et al - Towards
	A Process-Oriented Software Architecture Reconstruction Taxonomy.pdf:PDF},
  issn = {1534-5351},
  keywords = {software architecture, software architecture reconstruction, software
	development, taxonomy},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Riva2004,
  author = {Riva},
  title = {View-based Software Architecture Reconstruction},
  school = {Univ. of Vienna},
  year = {2004},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@PHDTHESIS{Sartipi2003a,
  author = {Sartipi},
  title = {Software Architecture Recovery based on Pattern Matching},
  school = {Univ. of Waterloo},
  year = {2003},
  note = {Revealer, bottom-up},
  file = {Sartipi - Software Architecture Recovery based on Pattern Matching
	(2003).pdf:papers/Sartipi - Software Architecture Recovery based
	on Pattern Matching (2003).pdf:PDF;Sartipi - [Thesis] Software Architecture
	Recovery based on Pattern Matching.pdf:papers/Sartipi - [Thesis]
	Software Architecture Recovery based on Pattern Matching.pdf:PDF;Sartipi
	- [Thesis] Software Architecture Recovery based on Pattern Matching.pdf:papers/Sartipi
	- [Thesis] Software Architecture Recovery based on Pattern Matching.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@ARTICLE{Sartipi2003,
  author = {Sartipi, K. and Kontogiannis, K.},
  title = {A User-assisted Approach to Component Clustering},
  journal = {J. Software Maintenance and Evolution: Research and Practice},
  year = {2003},
  volume = {15},
  pages = {265--295},
  number = {4},
  month = {July-Aug},
  abstract = {In this paper, we present a user assisted clustering technique for
	software architecture recovery based on a proximity measure that
	we call component association. The component association measure
	is computed on the shared properties among groups of highly related
	system entities. In this approach, the software system is modeled
	as an attributed relation graph with the software constructs (entities)
	represented as nodes and data/control dependencies represented as
	edges. The application of data mining techniques on the system graph
	allows to generate a component graph where the edges are labeled
	by the association strength values among the components. An interactive
	partitioning technique and environment is used to partition a system
	into cohesive subsystems where the graph visualization aids and cluster
	quality evaluation metrics are applied to assess and fine tune the
	partition by the user.},
  file = {Sartipi, Kontogiannis - A User-assisted Approach to Component Clustering.pdf:papers/Sartipi,
	Kontogiannis - A User-assisted Approach to Component Clustering.pdf:PDF;Sartipi,
	Kontogiannis - A User-assisted Approach to Component Clustering.pdf:papers/Sartipi,
	Kontogiannis - A User-assisted Approach to Component Clustering.pdf:PDF},
  keywords = {partitioning, association, data mining, architecture recovery, similarity,
	graph},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Shtern2007,
  author = {Shtern, Mark and Tzerpos, Vassilios},
  title = {Lossless Comparison of Nested Software Decompositions},
  booktitle = {Proc. 14th Working Conference on Reverse Engineering WCRE 2007},
  year = {2007},
  pages = {249--258},
  note = {UpMoJo},
  abstract = {Reverse engineering legacy software systems often involves the employment
	of clustering algorithms that automatically decompose a software
	system into subsys- tems. The decompositions created by existing
	software clustering algorithms are often nested, i.e. subsystems
	may contain other finer-grained subsystems as well as system resources,
	such as source files. It is rather sur- prising then, that almost
	all existing methods for de- composition comparison assume flat decompositions,
	i.e. subsystems only contain system resources. In this paper, we
	introduce UpMoJo, a novel com- parison method for software decompositions
	that can be applied to both nested and flat decompositions. The ben-
	efits of utilizing this method are presented in both ana- lytical
	and experimental fashion. We also compare Up- MoJo to the END framework,
	the only other existing method for nested decomposition comparison.},
  doi = {10.1109/WCRE.2007.32},
  file = {Shtern, Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:papers/Shtern,
	Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:PDF;Shtern,
	Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:papers/Shtern,
	Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:PDF},
  issn = {1095-1350},
  owner = {roden},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Shtern2004,
  author = {Shtern, M. and Tzerpos, V.},
  title = {A framework for the comparison of nested software decompositions},
  booktitle = {Proc. 11th Working Conference on Reverse Engineering},
  year = {2004},
  pages = {284--292},
  note = {END (Evaluation of Nested Decompositions)},
  abstract = {The evaluation of results obtained from software clustering algorithms
	has attracted the attention of many reverse engineering researchers.
	Several methods that compare flat decompositions of software systems
	have been presented in the literature. However, software clustering
	algorithms often produce nested decompositions. Converting nested
	decompositions to flat ones in order to compare them may remove significant
	information. We introduce a framework called END that reuses comparison
	methods for flat decompositions in order to compare nested decompositions
	without loss of information. We also present experimental results
	with END using several existing methods as plugins that demonstrate
	its usefulness.},
  doi = {10.1109/WCRE.2004.6},
  file = {Shtern, Tzerpos - A Framework for the Comparison of Nested Software
	Decompositions (2004).ps:papers/Shtern, Tzerpos - A Framework for
	the Comparison of Nested Software Decompositions (2004).ps:PostScript},
  issn = {1095-1350},
  keywords = {reverse engineering, software engineering, workstation clusters, END,
	comparison framework, flat decompositions, information loss, nested
	software decompositions, researcher, reverse engineering, software
	clustering algorithms},
  owner = {roden},
  timestamp = {2008.10.10}
}

@MASTERSTHESIS{Trifu2001,
  author = {Trifu},
  title = {Using Cluster Analysis in the Architecture Recovery of Object-Oriented
	Systems},
  school = {Univ. Karlsruhe},
  year = {2001},
  note = {James},
  file = {Trifu - [PhD] Using Cluster Analysis in the Architecture Recovery
	of Object-Oriented Systems (2001).pdf:papers/Trifu - [PhD] Using
	Cluster Analysis in the Architecture Recovery of Object-Oriented
	Systems (2001).pdf:PDF;Trifu - [PhD] Using Cluster Analysis in the
	Architecture Recovery of Object-Oriented Systems (2001).pdf:papers/Trifu
	- [PhD] Using Cluster Analysis in the Architecture Recovery of Object-Oriented
	Systems (2001).pdf:PDF},
  owner = {rodrigo},
  review = {Apenas 90 páginas, bom.
	
	
	Avalia com um sistema de 171 classes, o que considero pequeno.},
  timestamp = {2008.10.15}
}

@PHDTHESIS{Tzerpos2001,
  author = {Vassilios Tzerpos},
  title = {Comprehension-Driven Software Clustering},
  school = {University of Toronto},
  year = {2001},
  note = {MoJo},
  file = {Tzerpos - [PhD] Comprehension-Driven Software Clustering (2001).pdf:papers/Tzerpos
	- [PhD] Comprehension-Driven Software Clustering (2001).pdf:PDF;Tzerpos
	- [PhD] Comprehension-Driven Software Clustering (2001).pdf:papers/Tzerpos
	- [PhD] Comprehension-Driven Software Clustering (2001).pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Tzerpos2000,
  author = {Tzerpos, V. and Holt, R. C.},
  title = {ACDC: an algorithm for comprehension-driven clustering},
  booktitle = {Proc. Seventh Working Conference on Reverse Engineering},
  year = {2000},
  pages = {258--267},
  abstract = {The software clustering literature contains many different approaches
	that attempt to automatically decompose software systems. These approaches
	commonly utilize criteria or measures based on principles such as
	high cohesion and low coupling, information hiding etc. We present
	an algorithm that subscribes to a philosophy targeted towards program
	comprehension and based on subsystem patterns. We discuss the algorithm's
	implementation and describe experiments that demonstrate its usefulness},
  doi = {10.1109/WCRE.2000.891477},
  keywords = {pattern clustering, reverse engineering, software engineering, statistical
	analysis, ACCD, automatic software system decomposition, comprehension-driven
	clustering algorithm, high cohesion, information hiding, low coupling,
	program comprehension, software clustering, subsystem patterns},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Tzerpos2000a,
  author = {Tzerpos, V. and Holt, R. C.},
  title = {On the stability of software clustering algorithms},
  booktitle = {Proc. 8th International Workshop on Program Comprehension IWPC 2000},
  year = {2000},
  pages = {211--218},
  abstract = {A crucial step in understanding a large legacy software system is
	to decompose it into meaningful subsystems, which can be separately
	studied. This decomposition can be done either manually or automatically
	by a software clustering algorithm (SCA). Similar versions of a software
	system can be expected to have similar decompositions. We say an
	SCA is stable if small changes in its input (the software system)
	produce small changes in its output (the decomposition). The paper
	defines stability formally, explains why it is an essential property
	for an SCA, and gives experimental results from evaluating the stability
	of various decomposition algorithms suggested in the literature},
  doi = {10.1109/WPC.2000.852495},
  keywords = {pattern clustering, reverse engineering, software maintenance, SCA
	stability, decomposition algorithms, large legacy software system
	understanding, meaningful subsystems, software clustering algorithm
	stability},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Tzerpos1999,
  author = {Tzerpos, V. and Holt, R. C. },
  title = {MoJo: a distance metric for software clusterings},
  booktitle = {Proc. Sixth Working Conference on Reverse Engineering},
  year = {1999},
  pages = {187--193},
  note = {MoJo},
  abstract = {The software clustering problem has attracted much attention recently,
	since it is an integral part of the process of reverse engineering
	large software systems. A key problem in this research is the difficulty
	in comparing different approaches in an objective fashion. In this
	paper, we present a metric, called MoJo (Move-Join), that can be
	used in evaluating the similarity of two different decompositions
	of a software system. Our metric calculates a distance between two
	partitions of the same set of software resources. We begin by introducing
	the model we use. Then we present a heuristic algorithm that calculates
	the distance in an efficient fashion. Finally, we discuss some experiments
	that showcase the performance of the algorithm and the effectiveness
	of the metric},
  doi = {10.1109/WCRE.1999.806959},
  keywords = {heuristic programming, reverse engineering, software metrics, software
	performance evaluation, MoJo software metric, algorithm performance,
	cluster joining, cluster moving, distance metric, heuristic algorithm,
	large software systems, reverse engineering, software clusterings,
	software resource partitioning, software system dcomposition},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Tzerpos1998,
  author = {Tzerpos, V. and Holt, R. C. },
  title = {Software botryology. Automatic clustering of software systems},
  booktitle = {Proc. Ninth International Workshop on Database and Expert Systems
	Applications},
  year = {1998},
  pages = {811--818},
  abstract = {It has long been recognized that the decomposition of a large software
	system into &ldquo;meaningful&rdquo; subsystems is essential for
	both the development and maintenance phases of a software project.
	We introduce the term &ldquo;software botryology&rdquo; for the area
	of research that attempts to automatically cluster a software system
	(&ldquo;botrys&rdquo; is the ancient Greek word for a cluster of
	grapes). In this paper, we survey approaches to the clustering problem
	from researchers in the software engineering community. We also present
	clustering techniques used in other disciplines and argue that their
	utilization in a software context could lead to better solutions
	to the software clustering problem. Finally, we outline research
	challenges and open problems of interest},
  doi = {10.1109/DEXA.1998.707499},
  keywords = {computer aided software engineering, large-scale systems, pattern
	recognition, automatic software systems clustering, large software
	systems, meaningful subsystems, software botryology, software clustering,
	software development, software engineering, software maintenance,
	software project, software system decomposition},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Tzerpos1997,
  author = {Tzerpos, V. and Holt, R. C. },
  title = {The Orphan Adoption problem in architecture maintenance},
  booktitle = {Proc. Fourth Working Conference on Reverse Engineering},
  year = {1997},
  pages = {76--82},
  abstract = {A lot of research time has been devoted to finding a solution to the
	problem of automatic clustering, especially in the field of reverse
	engineering, where decomposing a legacy system to subsystems could
	be the key to understanding it. Maintaining the obtained structure
	as a system evolves, however, is a problem that has attracted much
	less attention. We present the Orphan Adoption problem in architecture
	maintenance, and propose an algorithm to solve it. We also present
	case studies that validate the usefulness of our algorithm},
  doi = {10.1109/WCRE.1997.624578},
  keywords = {computer aided software engineering, resource allocation, reverse
	engineering, software maintenance, Orphan Adoption problem, architecture
	maintenance, automatic clustering, case studies, legacy system, reverse
	engineering},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@MISC{Vasconcelos2008,
  author = {Vasconcelos and Werner},
  title = {Architecture Recovery and Evaluation Aiming at Program Understanding
	and Reuse},
  year = {2008},
  __markedentry = {[roden]},
  owner = {roden},
  timestamp = {2008.10.21}
}

@ARTICLE{Vasconcelos2008a,
  author = {Vasconcelos and Werner},
  title = {Refining the Architecture Recovery Approach ArchMine by Incrementally
	Performing Evaluation Studies},
  year = {2008},
  note = {SBES 2008. Tenho impresso.},
  __markedentry = {[roden]},
  owner = {roden},
  timestamp = {2008.10.21}
}

@INPROCEEDINGS{Vasconcelos2004,
  author = {Vasconcelos and Werner},
  title = {Software architecture recovery based on dynamic analysis},
  booktitle = {Brazilian Symposium on Software Engineering},
  year = {2004},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Wen2005,
  author = {Wen, Z. and Tzerpos, V. },
  title = {Software clustering based on omnipresent object detection},
  booktitle = {Proc. 13th International Workshop on Program Comprehension IWPC 2005},
  year = {2005},
  pages = {269--278},
  abstract = {The detection of omnipresent objects can be an important aid to the
	process of understanding a large software system. As a result, various
	detection techniques have been presented in the literature. However,
	these techniques do not take the subsystem structure into account
	when deciding whether an object is omnipresent or not. In this paper,
	we present a new set of detection methods for omnipresent objects
	that maintain that an object needs to be connected to a large number
	of subsystems before it is deemed omnipresent. We compare this novel
	approach to existing ones. We also introduce a framework that can
	improve the effectiveness of existing software clustering algorithms
	by combining them with an omnipresent object detection method. Experiments
	with two large software systems demonstrate the usefulness of this
	framework.},
  doi = {10.1109/WPC.2005.31},
  issn = {1092-8138},
  keywords = {object-oriented programming, reverse engineering, software maintenance,
	object-oriented programming, omnipresent object detection, software
	clustering, software maintenance, software subsystem structure, software
	system understanding},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Wen2004,
  author = {Wen, Zhihua and Tzerpos, V.},
  title = {An effectiveness measure for software clustering algorithms},
  booktitle = {Proc. 12th IEEE International Workshop on Program Comprehension},
  year = {2004},
  pages = {194--203},
  note = {MoJoFM},
  abstract = {Selecting an appropriate software clustering algorithm that can help
	the process of understanding a large software system is a challenging
	issue. The effectiveness of a particular algorithm may be influenced
	by a number of different factors, such as the types of decompositions
	produced, or the way clusters are named. In this paper, we introduce
	an effectiveness measure for software clustering algorithms based
	on Mojo distance, and describe an algorithm that calculates its value.
	We also present experiments that demonstrate its improved performance
	over previous measures, and show how it can be used to assess the
	effectiveness of software clustering algorithms.},
  doi = {10.1109/WPC.2004.1311061},
  issn = {1092-8138},
  keywords = {reverse engineering, Mojo distance, software clustering, software
	system, software understanding},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Wen2004a,
  author = {Wen, Zhihua and Tzerpos, V.},
  title = {Evaluating similarity measures for software decompositions},
  booktitle = {Proc. 20th IEEE International Conference on Software Maintenance},
  year = {2004},
  pages = {368--377},
  note = {EdgeMoJo},
  abstract = {One of the central questions that a similarity measure for software
	decompositions has to address is whether to consider discrepancies
	in terms of the nodes of a particular decomposition, or assess similarity
	based on differences in clustering the edges of the system's dependency
	graph. We argue that considering nodes or edges in isolation is too
	one-sided. We outline shortcomings of previous approaches, and introduce
	the first dissimilarity measure that takes both nodes and edges into
	account. We also present experiments on real and synthetic data sets
	that illustrate the differences between various measures.},
  doi = {10.1109/ICSM.2004.1357822},
  issn = {1063-6773},
  keywords = {software metrics, software performance evaluation, edge clustering,
	similarity measure evaluation, software decomposition, system dependency
	graph},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Wen2003,
  author = {Wen, Zhihua and Tzerpos, V. },
  title = {An optimal algorithm for MoJo distance},
  booktitle = {Proc. 11th IEEE International Workshop on Program Comprehension},
  year = {2003},
  pages = {227--235},
  note = {MoJo},
  abstract = {Effective comparison of different decompositions of a software system
	is integral for the evaluation of software clustering algorithms.
	One of the approaches that has been developed to tackle this issue
	is the MoJo distance measure. The original algorithm for the computation
	of MoJo distance was a heuristic one that only approximated the exact
	value. In this paper we introduce an algorithm that calculates the
	exact distance in polynomial time. We also present experiments that
	showcase that the new algorithm calculates MoJo distance more accurately
	and efficiently than before.},
  doi = {10.1109/WPC.2003.1199206},
  issn = {1092-8138},
  keywords = {reverse engineering, MoJo distance measure, optimal algorithm, software
	clustering algorithms, software system, software understanding},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@MISC{,
  author = {Wu and Holt},
  title = {A Program Extractor Suite for C and C++: Choosing the Right Tool
	for the Job},
  year = {2006},
  owner = {rodrigo},
  review = {Ferramentas analisadas:
	
	* CPPX
	
	* BFX
	
	* LDX 
	
	* CTSX},
  timestamp = {2008.10.25}
}

@INPROCEEDINGS{Wu2005,
  author = {Wu, J. and Hassan, A. E. and Holt, R. C.},
  title = {Comparison of clustering algorithms in the context of software evolution},
  booktitle = {Proc. 21st IEEE International Conference on ICSM'05 Software Maintenance},
  year = {2005},
  pages = {525--535},
  abstract = {To aid software analysis and maintenance tasks, a number of software
	clustering algorithms have been proposed to automatically partition
	a software system into meaningful subsystems or clusters. However,
	it is unknown whether these algorithms produce similar meaningful
	clusterings for similar versions of a real-life software system under
	continual change and growth. This paper describes a comparative study
	of six software clustering algorithms. We applied each of the algorithms
	to subsequent versions from five large open source systems. We conducted
	comparisons based on three criteria respectively: stability (Does
	the clustering change only modestly as the system undergoes modest
	updating?), authoritative-ness (Does the clustering reasonably approximate
	the structure an authority provides?) and extremity of cluster distribution
	(Does the clustering avoid huge clusters and many very small clusters?).
	Experimental results indicate that the studied algorithms exhibit
	distinct characteristics. For example, the clusterings from the most
	stable algorithm bear little similarity to the implemented system
	structure, while the clusterings from the least stable algorithm
	has the best cluster distribution. Based on obtained results, we
	claim that current automatic clustering algorithms need significant
	improvement to provide continual support for large software projects.},
  doi = {10.1109/ICSM.2005.31},
  file = {Comparison of Clustering Algorithms in the Context of Software Evolution.pdf:papers/Comparison
	of Clustering Algorithms in the Context of Software Evolution.pdf:PDF},
  issn = {1063-6773},
  keywords = {public domain software, software maintenance, software prototyping,
	authoritativeness criteria, automatic clustering algorithm, cluster
	distribution criteria, open source system, real-life software system,
	software clustering algorithm, software evolution, software maintenance,
	software projects, stability criteria},
  owner = {rodrigo},
  review = {Extrator de código C++ usado: CTSX},
  timestamp = {2008.10.10}
}

@MISC{Xanthos2006,
  author = {Xanthos},
  title = {Clustering Object-Oriented Software Systems using Spectral Graph
	Partitioning},
  year = {2006},
  file = {Xanthos - Clustering Object-Oriented Software Systems using Spectral
	Graph Partitioning.pdf:papers/Xanthos - Clustering Object-Oriented
	Software Systems using Spectral Graph Partitioning.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Xiao2005,
  author = {Xiao, Chenchen and Tzerpos, V. },
  title = {Software Clustering Based on Dynamic Dependencies},
  booktitle = {Proc. Ninth European Conference on Software Maintenance and Reengineering
	CSMR 2005},
  year = {2005},
  pages = {124--133},
  abstract = {The reverse engineering literature contains many software clustering
	approaches that attempt to cluster large software systems based on
	the static dependencies between software artifacts. However, the
	usefulness of clustering based on dynamic dependencies has not been
	investigated. It is possible that dynamic clusterings can provide
	a fresh outlook on the structure of a large software system. In this
	paper, we present an approach for the evaluation of dynamic clusterings.
	We apply this approach to a large open source software system, and
	present experimental results that suggest that dynamic clusterings
	have considerable merit.},
  doi = {10.1109/CSMR.2005.49},
  issn = {1534-5351},
  keywords = {program diagnostics, public domain software, reverse engineering,
	dynamic clustering evaluation, open source software system, reverse
	engineering, software artifacts, software clustering, static dependency},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@comment{jabref-meta: selector_publisher:}

@comment{jabref-meta: selector_author:}

@comment{jabref-meta: selector_journal:}

@comment{jabref-meta: selector_keywords:}

@comment{jabref-meta: groupsversion:3;}

@comment{jabref-meta: groupstree:
0 AllEntriesGroup:;
1 ExplicitGroup:Metrics for comparison of decompositions\;0\;Anquetil1
999\;Koschke2000\;Lakhotia1995\;Mitchell2001\;Mitchell2002\;Shtern2004
\;Shtern2007\;Tzerpos1999\;Tzerpos2001\;Wen2003\;Wen2004\;Wen2004a\;;
1 ExplicitGroup:Decomposition algorithm\;0\;Andritsos2005\;Mancoridis1
998\;;
1 ExplicitGroup:Lidos\;0\;Andreopoulos2005\;Anquetil1997\;Anquetil1999
\;Huynh2008\;Lindvall2008\;Maqbool2007\;Pollet2007\;Shtern2004\;;
1 ExplicitGroup:2008-10-20\;0\;Ding2001\;Li2005\;Mendonca1999\;;
}

