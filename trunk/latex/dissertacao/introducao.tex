% (5-10) páginas
%
%   Objetivos geral e específicos
%   Resultados esperados
%   Limitações do trabalho
%   Métodos
%   Justificativa
%   Descrição dos demais capítulos

% In practice, there are two kinds of software dependencies:	Static, or "compile-time," dependencies and dynamic, or "run-time," dependencies.
% Static dependencies capture the notion that one software module is necessary in order to compile another. In other words, A depends on B just in case the source code of A makes an explicit reference to B. In such a case, in order to compile A to an executable form, it is necessary to have access to B.
% Run-time dependencies, in contrast, are based on actual calling patterns of the software during operation, and vary according its use and deployment. They cannot, in general, be inferred from any a priori examination of the software code. For this reason, this investigation focuses on analyzing static software dependencies.

\chapter{Introdução}

\begin{section}{Motivação}

		Para um sistema de software ser bem sucedido não basta ele ser rápido, funcional e isento de defeitos. Esses atributos dizem respeito à qualidade, da forma como é enxergada pelos seus usuários, de uma versão do sistema. Para atender a demandas emergentes de seus usuários e incorporar novidades tecnológicas, no entanto, um sistema de software deve apresentar certos atributos de qualidade interna, visíveis apenas para os seus desenvolvedores. Ele precisa ser fácil de compreender, fácil de modificar e fácil de testar \cite{Parnas1994}.

		Um bom indicador da qualidade interna de um sistema de software é a estrutura de dependências entre as entidades que compõem o seu código-fonte. É natural que existam interações entre diversas entidades em um sistema, mas dependências indesejadas adicionam complexidade ao sistema, tornando mais difíceis as tarefas de compreender ou testar isoladamente as diversas partes do sistema \cite{Chidamber1994}. % CBO, página 11

		Analisar uma a uma as dependências de um sistema de software com a finalidade de extrair informações que apoiem a sua modificação é, no entanto, uma tarefa árdua \cite{Tonella2007}. Em um sistema com $n$ entidades, são $n^2$ potenciais dependências a se analisar. Em sistemas com mais que algumas dezenas de entidades, a quantidade de dependências potenciais é da ordem de centenas. %Ao tentar visualizar as dependências de um sistema grande através de diagramas de caixas e setas, as dependências acabam representadas como um emaranhado de setas. % Dunbar's number: 150
		
		% link com o parágrafo anterior?
		% Frente à dificuldade de 
		
		Para automatizar a análise de dependências, diversas ferramentas de engenharia reversa têm sido propostas. As ferramentas buscam identificar, entre outros, partes do sistema afetadas por uma mudança \cite{Arnold1993}, código duplicado \cite{Roy2007} e módulos arquiteturais \cite{Maqbool2007}.

	As tarefas que as ferramentas buscam automatizar, entretanto, envolvem alguma subjetividade, e por isso as ferramentas precisam ser avaliadas empiricamente. % TODO: dar mais detalhes.
	
  % When conducting empirical studies in reverse engineering, the variability of the skill and experience of the involved individuals may be high. Thus, subjects must be distributed carefully across the groups defined in the experimental design. Other sources of variability lie in the software development tasks given to the subjects, as well as the software systems themselves. These factors need to be taken into account and possibly controlled during the execution of the study.
	
	 A frequência com que as avaliações empíricas são realizadas, contudo, está aquém do que se espera de uma área de pesquisa madura \cite{Tonella2007}. Um estudo realizado com artigos sobre engenharia reversa publicados de 2002 a 2005 revelou que 25\% dos artigos não apresentam qualquer forma de avaliação empírica e, dentre os demais artigos, apenas 30\% recorrem a experimentos e estudos observacionais --- os outros 70\% se limitam a estudos de caso e relatos de experiência.

	% juntar com o recado do final do parágrafo anterior?
		A escassez de experimentos controlados em engenharia reversa pode ser explicada, em parte, pelo alto custo envolvido na realização de experimentos de qualidade. Em muitos casos, os experimentos envolvem um planejamento cuidadoso e dependem da disponibilidade de desenvolvedores experientes.

		Uma abordagem empregada quando os experimentos controlados são caros é a simulação baseada em modelos computacionais e estatísticos. Na área de redes e sistemas distribuídos, por exemplo, é frequente o uso de ambientes de simulação de redes, que modelam o funcionamento de uma rede de computadores, incluindo, às vezes, modelos de falhas de hardware e até modelos de comportamento de usuários \cite{White2002}. A simulação oferece um meio para se realizar experimentos controlados a um custo baixo. Naturalmente, há o risco de os modelos usados na simulação não corresponderem à realidade nos aspectos relevantes para o experimento. Todavia, TODO completar

		Na engenharia de software, a abordagem de modelagem e simulação já foi usada no estudo de processos de desenvolvimento \cite{Stopford2008}, mas em geral é uma abordagem pouco explorada. Se protocolos de rede podem ser avaliados em experimentos simulados com modelos de redes de computadores, por que não avaliar ferramentas de engenharia reversa com base em dependências que foram construídas a partir da simulação controlada de um modelo de dependências?
		
\end{section}

\begin{section}{Objetivos}
	O objetivo desta pesquisa é descobrir e avaliar modelos de dependências entre entidades do código-fonte de sistemas de software com a finalidade de apoiar o uso de simulações na avaliação de técnicas de engenharia reversa que se baseiam na análise de dependências.
	
	O objetivo se desdobra nos seguintes objetivos específicos:
	
	\begin{enumerate}
		\item descobrir modelos computacionais que podem ser interpretados como modelos de dependências entre entidades de código-fonte;
		\item avaliar os modelos de acordo com a similaridade entre a estrutura das dependências produzidas pelos modelos e a estrutura das dependências que são extraídas de sistemas de software reais;
		\item realizar uma prova de conceito para demonstrar a viabilidade da abordagem de simulação para a avaliação de técnicas e ferramentas que se baseiam na análise de dependências.
	\end{enumerate}
	
	A fim de melhor representar a forma como sistemas de software são idealizados e construídos, optamos por considerar modelos em que as entidades de código-fonte estão organizadas em módulos. % ficou muito seco? desculpa esfarrapada?
	
\end{section}

\begin{section}{Métodos e Resultados}
	
	A teoria das redes complexas estuda métodos para analisar redes (ou grafos) encontradas nos mais diversos domínios, como redes sociais, redes de computadores e redes metabólicas. A aplicação de tais métodos levou à descoberta de propriedades comuns a um grande número de redes, bem como modelos de redes que incorporam essas propriedades.
	
	Dado que as dependências em um sistema de software formam uma rede, é possível aplicar nesta pesquisa alguns dos métodos, modelos e descobertas da teoria das redes complexas, os quais são apresentados no Capítulo \ref{cap:redes}.
	
	Foram encontrados na literatura dois modelos de redes organizadas em módulos, denominados CGW e LFR, os quais podem ser interpretados como modelos de dependências entre entidades de software. Esses modelos são apresentados no Capítulo \ref{cap:redes}. Um terceiro modelo, o BCR+, foi desenvolvido no contexto desta pesquisa. O modelo BCR+ é descrito em detalhes no Capítulo \ref{cap:bcr}.
	
	A avaliação dos modelos, descrita no Capítulo \ref{cap:avaliacao}, teve como base a simulação dos três modelos. As redes produzidas pelos modelos foram comparadas com redes de dependências extraídas de sistemas de software escritos em uma linguagem de programação orientada a objetos. Os resultados indicam que, com uma escolha adequada de parâmetros, os três modelos produzem redes que se assemelham a redes de dependências entre entidades de software (ao menos no caso de linguagens de programação orientadas a objetos).
	
	Para a prova de conceito foi escolhido o problema de recuperação de arquitetura de software. Algoritmos de agrupamento usados na atividade de recuperação de arquitetura foram aplicados a redes de dependências geradas pelo modelo BCR+ e os resultados foram analisados. No Capítulo \ref{cap:estudo} é feita uma introdução ao problema de recuperação de arquitetura e, a seguir, são apresentados os métodos e resultados da prova de conceito.
	
	No Capítulo \ref{cap:trabrel} este trabalho é comparado a trabalhos relacionados. No Capítulo \ref{cap:conclusao} são apresentadas as conclusões, contribuições e limitações deste trabalho.
	
	% Como resultado, foram encontrados dois modelos de redes apropriados para representar dependências entre entidades, e um modelo que foi criado a partir da adaptação de um modelo existente. O novo modelo é apresentado em detalhes no Capítulo ....
	% 
	% A avaliação dos modelos foi realizada através da simulação dos modelos e posterior uso de métodos asd.sd..asd.... Linguagens OO apenas. A avaliação e os resultados são apresentados no Capítulo ....
	% 
	% Para a prova de conceito foi escolhido o problema de recuperação de arquitetura. A prova de conceito .. no Capítulo ....
	
\end{section}
