% Sistemas legados, divisão em módulos, equipes de desenvolvimento
% Algoritmo de clustering, aproximação dos módulos
% Avaliação com sistemas cujos módulos sejam conhecidos, especialista
% N² vantagens! Sistemas grandes. Muitos sistemas. Parâmetros ajustáveis!
% Neste estudo mostramos os modelos e avaliamos, comparativamente, seu realismo.

% http://swasr.googlecode.com/svn/trunk/latex/artigo1/artigo1.pdf
\documentclass{acm_proc_article-sp}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{url}

%the story is not what you did, but rather
%  what you show, new ideas, new insights
%  why interesting, important?
%why is the story of interest to others?
%  universal truths, hot topic, surprises or unexpected results?

% Ordem de escrita
%   Resultados
%   Discussão
%   Introdução
%   Materiais e Métodos
%   Abstract
%   Título


% == PLANEJAMENTO DO EXPERIMENTO ==
% 
% INGREDIENTES
%
%   Dois sistemas, um pequeno (?) e um maior (IRPF)
%   Modelos de geração de redes com estrutura de módulos embutida: Rodrigo2008 e Lancichinetti
%   Modelos sem estrutura de módulos: barabasi, bollobas, configuration model.
%
% MODO DE PREPARO
%
%   Analisar métricas dos sistemas (distribuição de graus, distribuição do coeficiente de clustering, correlação de graus).
%   Extrair a arquitetura dos sistemas: quais são os módulos e quais módulos se relacionam. Analisar a distribuição dos tamanhos dos módulos.
%   "Tunar" os parâmetros dos modelos para gerar redes com as mesmas métricas dos sistemas reais
%   Rodar os modelos diversas vezes com os parâmetros encontrados para gerar diversas redes para cada sistema.
%   Comparar redes sintéticas com as redes reais correspondentes através da distância entre redes de Garcia.
% 
% RESULTADOS
%
%   Modelos com estrutura de módulos embutida resultam em redes mais parecidas com as redes reais do que os modelos sem módulos? (Em outras palavras: a informação sobre tamanhos dos módulos e a maneira como os módulos se ligam realmente são uma vantagem?)
%   As redes sintéticas são realistas? Quais as diferenças entre as sintéticas e as reais?
%   Os módulos das redes sintéticas também podem ser decompostos em módulos, como nas redes reais?
%
% O QUE MAIS
%
%   Ver no wiki as observações subjetivas sobre os modelos.
%   Começar pelo sistema pequeno, pra obter resultados mais rápidos, e então reproduzir o método com o sistema grande
%   A implementação do modelo de Rodrigo2008 precisa ser revista pra ficar mais eficiente (está muito lento!)
%   Podemos usar uma distância de Garcia usando o coeficiente de clustering em vez de usar a distância propriamente dita.


\begin{document}
\title{Artigo 1} % Avaliação de modelos de síntese de software
\author{Rodrigo Rocha Gomes e Souza}
\maketitle

\begin{abstract}

% goals, results, and the main conclusions of your study

% Kent Beck's sentences: The first states the problem. The second states why the problem is a problem. The third is my startling sentence. The fourth states the implication of my startling sentence.

\end{abstract}

\section{Introdução} % why

% why you have investigated the question
% 
% how it relates to earlier research that has been done in the field
% 
% 1. Open with two or three sentences placing your study subject in context
% 2. Follow with a description of the problem and its history, including previous research
% 3. Describe how your work addresses a gap in existing knowledge or ability (here's where you'll state why you've undertaken this study). 
% 4. State what information your article will address. 

Recuperação de arquitetura de \emph{software} é o ato de extrair aspectos da arquitetura de um sistema através de artefatos como código-fonte. Muitos esforços têm se concentrado no particionamento de sistemas em módulos arquiteturais --- grupos coesos de entidades de código-fonte (classes ou funções) --- através de algoritmos de agrupamento (\emph{clustering}). Não há consenso, no entanto, sobre quais algoritmos de agrupamento são mais adequados para a tarefa de recuperação de módulos arquiteturais.

Uma formas de avaliar um algoritmo de agrupamento consiste em aplicá-lo a um sistema cuja organização do código-fonte em módulos seja conhecida e então comparar os módulos do sistema com os módulos encontrados pelo algoritmo através de uma medida de distância entre particionamentos. Infelizmente é difícil encontrar sistemas documentados nesse nível de detalhe, e por isso os estudos experimentais realizados são superficiais. Alguns estudos revelam que a avaliação de um algoritmo varia bastante de sistema para sistema. Devido ao pequeno tamanho das amostras analisadas, no entanto, não existe uma explicação que permita que se determine a priori se um algoritmo fornece bons resultados para um sistema.

%Alguns experimentos revelam que o algoritmo mais adequado para um sistema pode ter um desempenho medíocre quando aplicado a outro sistema mas, devido às amostras pequenas, não foi encontrada uma explicação para essa variação.
% consideram amostras pequenas

%OS ESTUDOS FEITOS ASSIM NÃO SÃO CONTUNDENTES, OBTÊM RESULTADOS DIFERENTES PARA SISTEMAS DIFERENTES E NÃO TÊM NENHUMA PISTA SOBRE O QUE FAZ UM ALGORITMO SER BOM EM UM SISTEMA E RUIM EM OUTRO.

Propomos uma abordagem de avaliação complementar, baseada na análise de sistemas de software sintéticos. Esses sistemas são gerados por computador a partir de modelos parametrizáveis e obedecem a estruturas modulares conhecidas. Com essa abordagem é possível avaliar algoritmos de agrupamento com amostras arbitrariamente grandes de sistemas arbitrariamente complexos e, sobretudo, estudar como o desempenho dos algoritmos é afetado por parâmetros que definem os sistemas sintéticos.

Neste artigo apresentamos um modelo para a geração de sistemas sintéticos e avaliamos o realismo desse modelo, isto é, a similaridade entre os sistemas sintéticos e sistemas reais. Para fins de comparação, essa mesma análise é realizada sobre modelos genéricos disponíveis na literatura sobre redes complexas.

Na próxima seção.... na seção x.... por fim, .....

\section{Fundamentação Teórica}

\subsection{Redes de Dependências entre Classes}

Para recuperar os módulos de um sistema orientado a objetos é suficiente considerar as suas classes e os relacionamentos de dependência entre elas --- uma rede de dependências entre classes. Essas redes podem ser extraídas automaticamente a partir da análise estática do código-fonte ou do código objeto do sistema que se deseja estudar.

Pesquisas recentes na teoria das redes complexas encontraram características comuns a redes que representam objetos de diversos domínios (sociologia, biologia, linguística, tecnologia etc.), incluindo as redes de dependências entre classes. A partir daí foram criados diversos modelos que procuram explicar como essas redes são formadas.

\subsection{Conceitos}

Arestas externas

Lei de potência

%Neste estudo foram avaliados três modelos de geração de redes complexas: o modelo de configuração, o modelo de Bollobás \cite{Bollobas2003}, o modelo de Lancichinetti, Fortunato e Radicchi \cite{Lancichinetti2008} e um novo modelo, baseado no modelo de Bollobás. Os dois últimos modelos geram redes com uma estrutura de módulos embutida.

\subsection{Modelos de Geração de Redes Complexas}

Bollobas: pensando na Web. Não tem estrutura de módulos embutida. Parâmetros são probabilidades.

O modelo X...

TODOS ASSUMEM LEI DE POTÊNCIA

\subsubsection{Modelo LFR}

Lancichinetti, Fortunato e Radicchi \cite{Lancichinetti2008} criaram um modelo de rede com estrutura de módulos embutida que é usado para avaliar algoritmos de clustering. O modelo não foi baseado em nenhum domínio em particular, mas incorpora características encontradas em redes de vários domínios. Ele gera grafos não-orientados e não-ponderados cuja distribuição dos graus dos vértices e cuja distribuição dos tamanhos dos módulos são ambas leis de potência e, portanto, bastante heterogêneas. Mais precisamente, o número de vértices cujo grau é $k$ é proporcional a $k^{-\gamma_1}$, onde o expoente $\gamma_1$ tipicamente varia entre 2 e 3, e o número de módulos com $x$ vértices é proporcional a $x^{\gamma_2}$, com $\gamma_2$ entre 1 e 2.

O modelo possui os seguintes parâmetros:
\begin{itemize}
  \item quantidade de vértices ($N$);
  \item expoente da distribuição de graus ($\gamma_2$);
  \item grau médio ($\langle k \rangle$);
  \item grau máximo ($k_{max}$);
  \item expoente da distribuição de tamanhos dos módulos ($\gamma_1$);
  \item número mínimo de vértices por módulo ($c_{min}$);
  \item número máximo de vértices por módulo ($c_{max}$);
  \item parâmetro de mistura ($\mu$).
\end{itemize}

O modelo gera redes que seguem aproximadamente os parâmetros fornecidos. O parâmetro de mistura é um número entre 0 e 1 que indica a fração das arestas de cada vértice que são compartilhadas com vértices de outro módulo. Por exemplo, se $\mu = 0,4$, então 40\% das arestas de cada vértice são ligadas a vértices que não pertencem ao mesmo módulo do vértice de origem.

  \textbf{Discussão}

  O modelo gera grafos não-orientados, uma representação muito simplificada das redes de dependências entre classes. Por essa razão ele não é adequado para testar algoritmos de agrupamento que consideram a informação de sentido das arestas. Além disso, ele considera que todos os vértices possuem arestas para vértices de outros módulos, o que certamente não é verdade no domínio de software. Por fim, os vértices de um módulo podem se ligar a vértices de qualquer outro módulo, sem restrição. Essa característica difere do que se encontra em programas de computador, onde as dependências entre módulos são controladas (por exemplo, ao se adotar uma arquitetura em camadas).
% rápido: cerca de 13s para 1658 vértices no athlon 64 3000+ com 1 GB de RAM.

\subsubsection{Modelo Aleatório com Módulos}

Baseado em Erdos-Renyi...

\subsection{O modelo S}

Considerando as limitações do modelo LFR, propomos um novo modelo de rede com estrutura de módulos embutida, baseado no modelo de grafo orientado de Bollobás \cite{Bollobas2003}, que foi inspirado na rede de links entre páginas da Web. O modelo possui os seguintes parâmetros:

\begin{itemize}
  \item número de vértices ($N$);
  \item arquitetura ($a$) --- uma rede representando os módulos e as ligações permitidas entre módulos;
  \item probabilidades $\alpha$, $\beta$ e $\gamma$, tal que $\alpha + \beta + \gamma = 1$;
  \item probabilidade $\mu$;
  \item $\delta_{in}$ e $\delta_{out}$.
\end{itemize}

Inicialmente é criada uma rede contendo um vértice com autolaço (aresta ligando o vértice a ele próprio) para cada módulo representado na arquitetura e cada vértice é incluído no módulo correspondente. O algoritmo consiste em alterações sucessivas à rede até se alcançar o número de vértices desejado. Na descrição a seguir, ``escolher um vértice $v$ de acordo com $k_{out} + \delta_{out}$'' significa escolher um vértice $v$ de modo que a probabilidade de se escolher um vértice $v_i$ é proporcional a $k_{out}(v_i) + \delta_{out}$, onde $k_{out}(v_i)$ é o grau de saída do vértice $v_i$. Analogamente, $k_{in}$ significa grau de entrada.

Cada iteração do algoritmo realiza uma das seguintes alterações na rede:

\begin{itemize}
  \item \textbf{Criação de vértice com grau de saída = 1}. Com probabilidade $\alpha$ é criado um vértice $v$ juntamente com uma aresta de $v$ para um vértice pré-existente $w$, onde $w$ é escolhido de acordo com $k_{in} + \delta_{in}$. O vértice $v$ é incluído no módulo de $w$.
  \item \textbf{Criação de vértice com grau de entrada = 1}. Com probabilidade $\gamma$ é criado um vértice $w$ juntamente com uma aresta de um vértice existente $v$ para $w$, onde $v$ é escolhido de acordo com $k_{out} + \delta_{out}$. O vértice $w$ é incluído no módulo de $v$.
  \item \textbf{Criação de uma aresta}. Com probabilidade $\beta$ é criada uma aresta de um vértice existente $v$ para um vértice existente $w$, $v$ escolhido de acordo com $k_{out} + \delta_{out}$ e $w$ escolhido de acordo com $k_{in} + \delta_{in}$. Com probabilidade $1 - \mu$, $w$ é escolhido dentre os vértices do mesmo módulo que $v$; com probabilidade $\mu$, $w$ é escolhido dentre os vértices de módulos adjacentes ao módulo de $v$ segundo a arquitetura. 
\end{itemize}

Como neste modelo a rede é orientada, pode-se considerar separadamente uma distribuição dos graus de entrada e uma distribuição dos graus de saída. Da mesma forma que no modelo LFR, essas distribuições seguem leis de potência, com expoentes $X_in$ e $X_out$, respectivamente. Pode-se demonstrar analiticamente que, quando N tende a infinito, os expoentes podem ser calculados pelas seguintes expressões \cite{Bollobas2003}:

$X_{in} = 1 + \frac{1 + \delta_{in}(\alpha + \gamma)}{\alpha + \beta}$

$X_{out} = 1 + \frac{\beta + \gamma}{1 + \delta_{out}(\alpha + \gamma)}$

  \textbf{Discussão}

Este modelo supera as limitações encontradas no modelo LFR: as redes são orientadas, nem todos os vértices são necessariamente ligados a vértices de outros módulos e é possível restringir as dependências entre módulos através da arquitetura fornecida como parâmetro. Além disso ele é um modelo evolutivo: o algoritmo pode ter como ponto de partida uma rede existente e então expandi-la criando mais vértices e arestas. A desvantagem em relação ao modelo LFR é o controle reduzido sobre a rede: não há como impor restrições sobre o grau máximo, sobre a distribuição dos tamanhos dos módulos e nem estabelecer limites de tamanho para os módulos.
% experimentalmente, tamanhos x dos módulos ~ x^-1. Deve ser fácil provar analiticamente.
% tem outra coisa:   multi-arestas, autolaços (normalmente devem ser removidos) podem afetar as distribuiçãos

%Poréns determinados experimentalmente (conclusões):
%  as redes geradas podem desviar muito dos valores esperados para as métricas. acreditamos que devido a multi-arestas, autolaços.
%  é mais lento (pelo menos a minha implementação)

\section{Experimento} % how

Realizamos um experimento a fim de avaliar os modelos de redes de acordo com a sua capacidade de gerar redes semelhantes a redes de sistemas reais. Para isso consideramos dois sistemas, o jogo VilloNanny 2.2.4 e o programa IRPF 2009, e ajustamos os parâmetros dos modelos de acordo com métricas extraídas desses sistemas. O experimento foi dividido em cinco etapas: extração das redes dos sistemas (redes reais), análise das redes reais, sintonia dos parâmetros dos modelos, geração de redes sintéticas e comparação entre redes sintéticas e as redes reais correspondentes. 

%Neste estudo consideramos dois sistemas de software reais e três modelos de geração de redes complexas.

\subsection{Extração}

Os sistemas analisados são implementados na linguagem Java e foram distribuídos em diversos arquivos JAR, cada arquivo contendo várias classes. Alguns arquivos JAR contêm classes específicas de um sistema, mas muitos deles são bibliotecas; consideramos que as bibliotecas que um sistema usa são parte do sistema, e cada arquivo JAR corresponde a um módulo arquitetural. Essa é uma aproximação razoável, uma vez que arquivos JAR distintos são, em geral, desenvolvidos por equipes diferentes e distribuídos independentemente. 
%(Naturalmente, cada um desses módulos pode ser decomposto em submódulos, formando uma hierarquia de módulos XXX)

A ferramenta DepFind\footnote{\url{http://depfind.sourceforge.net/}} foi usada para extrair, através da análise estática dos arquivos JAR, a rede de dependências entre as classes. A organização em módulos foi extraída a partir da enumeração das classes contidas em cada arquivo JAR.

\subsection{Análise de sistemas reais}

O grau de um vértice é o número de arestas que estão ligadas a ele. Baseado em pesquisas anteriores, consideramos que a distribuição estatística dos graus dos vértices segue aproximadamente uma lei de potência, $P(k) ~ k^{-\gamma}$, onde $P(k)$ é a probabilidade de um vértice escolhido possuir grau $k$ e $\gamma$ é o expoente da distribuição. Usamos esse mesmo tipo de distribuição para modelar a distribuição dos tamanhos dos módulos.


Para cada rede foram coletadas diversas métricas da teoria dos grafos e da teoria das redes complexas:

\begin{itemize}
\item número de vértices - ...
\item número de arestas - ...
\item número de arestas externas - número de arestas que ligam vértices em módulos distintos.

\item grau médio - ...
\item grau máximo - ...
\item expoente da distribuição de graus - ...

\item número de módulos
\item tamanho do menor módulo
\item tamanho do maior módulo
\item expoente da distribuição dos tamanhos dos módulos

%\item coeficiente de clustering
\end{itemize}

Os expoentes das distribuições de graus e de tamanhos dos módulos foram estimados através da técnica de máxima verossimilhança \cite{Clauset2007} através de uma implementação disponível disponível na Internet\footnote{\url{http://www.santafe.edu/~aaronc/powerlaws/}}. 
%No caso da distribuição dos tamanhos dos módulos fixamos xmin = 1, pois o número de módulos é pequeno...

Extraímos ainda a rede de dependências entre MÓDULOS...

\subsection{Sintonia dos parâmetros dos modelos}

Dado um sistema e um modelo, os parâmetros do modelo foram escolhidos de forma a gerar redes cujas métricas fossem próximas às metricas da rede do sistema.

No modelo de Lancichinetti os parâmetros correspondem às métricas.

No outro modelo isso foi feito na tentativa e erro (oops, experimentalmente).

Distribuição de graus foi usada para todos os modelos.

Modelo de Lancichinetti tem os seguintes parâmetros.

No modelo de Bollobás os parâmetros não correspondem a métricas da rede resultante, e por isso foi preciso sintonizar os parâmetros de forma experimental (correspondência analítica existe, mas não consegui usar).

\subsection{Geração de sistemas sintéticos}

Foram gerados 10 redes para cada modelo. Por que 10?

\subsection{Comparação com os sistemas reais}

Usamos a métrica de distância entre redes definida por \cite{Andrade2008}, implementação de Charles. Essa distância leva em consideração aspectos locais das redes. Comparar apenas os parâmetros globais não é tão bom porque não diferencia entre modelos, já que existem vários modelos que, como se sabe, geram power law.

% talvez usar um ks.test (visualmente: qqplot) dos graus da rede sintética vs. graus da rede real (e o mesmo com outros parâmetros) [ver também AIC no pacote stats]
% talvez usar library(igraph) g = read.graph("..."), graph.motif(g) e comparar a frequencia de motifs através de ks.test. Desenho do motif: graph.isocreate(3, i), i entre 0 e 15

Consideramos para cada modelo a média entre as distâncias de cada rede gerada pelo modelo.

%particular techniques used and why, if relevant
%modifications of any techniques; be sure to describe the modification
%assumptions underlying the study 
%statistical methods, including software programs 

\section{Resultados} % what was found

TABELA 1: sistemas analisados. Nome, versão, métricas (tamanho, número de módulos, ....)

TABELA 2: métricas das redes sintéticas.

TABELA 3 (ou GRÁFICO): distâncias

%  * present results clearly and logically
%  * avoid excess verbiage
%  * consider providing a one-sentence summary at the beginning of each paragraph if you think it will help your reader understand your data 

\section{Discussão} % why it's significant

% Recapitulando o que este trabalho fez:

% Produção de um modelo, baseado em um modelo existente, de geração de redes de software com estrutura de módulos embutida.

% Comparação desse modelo com um modelo presente na literatura usando como critério a semelhança com redes de software.

% Análise desse modelo modelos de geração de redes com estrutura de módulos embutida, e da semelhança dessas redes com redes de software.

% -----

O quão bem o modelo funciona, vantagens e desvantagens em relação a outras abordagens (complementares).

Especulação sobre o papel da modelagem estatística na engenharia de software.

Focar na hipótese: redes sintéticas com parâmetros ajustáveis dão insights sobre as ferramentas de engenharia reversa / evolução de software.
% redes sintéticos são uma boa aproximação de redes reais

%how useful this technique is: how well did it work, what are the benefits and drawbacks, etc

%This section centers on speculation

%Focus your discussion around a particular question or hypothesis

Trabalhos futuros: explorar métricas de arquitetura, avaliar algoritmos de clustering, considerar outros modelos.
% considerar o uso de arestas orientadas e pesos das arestas .

%\bibliographystyle{apalike}
\bibliographystyle{abbrv}
\bibliography{complex-networks,rodrigo-mestrado}

\end{document}








%arbitrariamente complexos

%Propomos sistemas de software gerados por computador, COM ESTRUTURA DE MÓDULOS EMBUTIDA. VANTAGENS: É POSSÍVEL AJUSTAR PARÂMETROS DOS SISTEMAS GERADOS E ASSIM GANHAR INSIGHT SOBRE OS PARÂMETROS QUE INFLUENCIAM A ACURÁCIA DE UM ALGORITMO. EM PARTICULAR, É POSSÍVEL CONTROLAR O TAMANHO DO SOFTWARE GERADO E, ASSIM, GERAR SISTEMAS GRANDES, MAIS PARECIDOS COM OS QUE SERIAM ANALISADOS PELAS TÉCNICAS EM UM CENÁRIO REAL.

%embora existam alguns trabalhos avaliando algoritmos de recuperação de arquitetura, os resultados experimentais não dão pistas sobre por que os algoritmos são bons em uns critérios e ruins em outros, quais são as coisas que influenciam o desempenho do algoritmo.

%Neste estudo nos concentraremos em sistemas orientados a objeto, para simplificar, mas os conceitos provavelmente podem ser aplicados a outros paradigmas como procedimental ou funcional. 
%Muitas técnicas de recuperação de arquitetura analisam uma representação abstrata de sistemas de software, as redes de dependências entre classes. Nessas redes, os vértices representam classes e existe uma aresta do vértice A para o vértice B se a classe A depende da classe B para funcionar corretamente. Essa dependência pode ser resultado diversos tipos de interação entre as classes: A estende B, um método de A chama um método de B etc. A extração da rede de um sistema de software se dá através da análise estática de seu código-fonte ou do código objeto.

