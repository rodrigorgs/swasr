% This file was created with JabRef 2.4.2.
% Encoding: UTF8

@article{Tonella2007,
 author = {Tonella, Paolo and Torchiano, Marco and Du Bois, Bart and Syst\"{a}, Tarja},
 title = {Empirical studies in reverse engineering: state of the art and future trends},
 journal = {Empirical Softw. Engg.},
 volume = {12},
 number = {5},
 year = {2007},
 issn = {1382-3256},
 pages = {551--571},
 doi = {http://dx.doi.org/10.1007/s10664-007-9037-5},
 publisher = {Kluwer Academic Publishers},
 address = {Hingham, MA, USA},
 }

@INPROCEEDINGS{Aiello2000a,
  author = {William Aiello and Fan Chung and Linyuan Lu},
  title = {A random graph model for massive graphs},
  booktitle = {STOC '00: Proceedings of the thirty-second annual ACM symposium on
	Theory of computing},
  year = {2000},
  pages = {171--180},
  address = {New York, NY, USA},
  publisher = {ACM},
  note = {ACL Model},
  doi = {http://doi.acm.org/10.1145/335305.335326},
  file = {Aiello et al - A Random Graph Model for Massive Graphs (2000).pdf:artigos/Aiello
	et al - A Random Graph Model for Massive Graphs (2000).pdf:PDF},
  isbn = {1-58113-184-4},
  location = {Portland, Oregon, United States},
  owner = {rodrigo},
  timestamp = {2009.01.11}
}

@ARTICLE{Aiello2000b,
  author = {William Aiello and Fan Chung and Linyuan Lu},
  title = {A random graph model for power law graphs},
  journal = {Experimental Math},
  year = {2000},
  volume = {10},
  pages = {53--66},
  file = {Aiello et al - A Random Graph Model for Power Law Graphs (2000).pdf:artigos/Aiello
	et al - A Random Graph Model for Power Law Graphs (2000).pdf:PDF},
  owner = {rodrigo},
  timestamp = {2009.01.11}
}

@ARTICLE{Albert2000,
  author = {Reka Albert and Albert-Laszlo Barabasi},
  title = {Topology of evolving networks: local events and universality},
  journal = {Physical Review Letters},
  year = {2000},
  volume = {85},
  pages = {5234},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0005085}
}

@ARTICLE{Albert2002,
  author = {Reka Albert and Albert-László Barabási},
  title = {Statistical mechanics of complex networks},
  journal = {Reviews of Modern Physics},
  year = {2002},
  volume = {74},
  pages = {47},
  note = {Revisão de redes complexas. É como um Linked para o público acadêmico.},
  abstract = {Complex networks describe a wide range of systems in nature and society,
	much quoted examples including the cell, a network of chemicals linked
	by chemical reactions, or the Internet, a network of routers and
	computers connected by physical links. While traditionally these
	systems were modeled as random graphs, it is increasingly recognized
	that the topology and evolution of real networks is governed by robust
	organizing principles. Here we review the recent advances in the
	field of complex networks, focusing on the statistical mechanics
	of network topology and dynamics. After reviewing the empirical data
	that motivated the recent interest in networks, we discuss the main
	models and analytical tools, covering random graphs, small-world
	and scale-free networks, as well as the interplay between topology
	and the network's robustness against failures and attacks.},
  file = {Barabasi e Albert - Statistical mechanics of complex networks (2002).pdf:Para
	categorizar/Barabasi e Albert - Statistical mechanics of complex
	networks (2002).pdf:PDF},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0106096}
}

@ARTICLE{Amaral00,
  author = {Amaral, L. A. and Scala, A. and Barthelemy, M. and Stanley, H. E.},
  title = {Classes of small-world networks},
  journal = {Proceedings of the National Academy of Sciences},
  year = {2000},
  volume = {97},
  pages = {11149--11152},
  number = {21},
  abstract = {We study the statistical properties of a variety of diverse real-world
	networks. We present evidence of the occurrence of three classes
	of small-world networks: (a) scale-free networks, characterized by
	a vertex connectivity distribution that decays as a power law; (b)
	broad-scale networks, characterized by a connectivity distribution
	that has a power law regime followed by a sharp cutoff; and (c) single-scale
	networks, characterized by a connectivity distribution with a fast
	decaying tail. Moreover, we note for the classes of broad-scale and
	single-scale networks that there are constraints limiting the addition
	of new links. Our results suggest that the nature of such constraints
	may be the controlling factor for the emergence of different classes
	of networks.},
  citeulike-article-id = {3339778},
  keywords = {networks, small-world},
  posted-at = {2008-09-26 13:27:50},
  priority = {0},
  review = {= Citações =
	
	
	... both types of contraints [aging and cost constraints] lead to
	cut-offs on the power-law decay of the tail of connectivity distributions
	and that for strong enough constraints no power-law region is visible.}
}

@ARTICLE{Andrade2008,
  author = {Andrade, Roberto F. S. and Miranda, José G. V. and Pinho, Suani T.
	R. and Lobão, Thierry Petit},
  title = {Measuring distances between complex networks},
  journal = {Physics Letters A},
  year = {2008},
  volume = {372},
  pages = {5265--5269},
  number = {32},
  month = {August},
  abstract = {A previously introduced concept of higher order neighborhoods in complex
	networks, [R.F.S. Andrade, J.G.V. Miranda, T.P. Lobão, Phys. Rev.
	E 73 (2006) 046101] is used to define a distance between networks
	with the same number of nodes. With such measure, expressed in terms
	of the matrix elements of the neighborhood matrices of each network,
	it is possible to compare, in a quantitative way, how far apart in
	the space of neighborhood matrices two networks are. The distance
	between these matrices depends on both the network topologies and
	the adopted node numberings. While the numbering of one network is
	fixed, a Monte Carlo algorithm is used to find the best numbering
	of the other network, in the sense that it minimizes the distance
	between the matrices. The minimal value found for the distance reflects
	differences in the neighborhood structures of the two networks that
	arise only from distinct topologies. This procedure ends up by providing
	a projection of the first network on the pattern of the second one.
	Examples are worked out allowing for a quantitative comparison for
	distances among distinct networks, as well as among distinct realizations
	of random networks.},
  doi = {doi:10.1016/j.physleta.2008.06.044},
  file = {Garcia et al - Measuring distances between complex networks.pdf:novos/Garcia
	et al - Measuring distances between complex networks.pdf:PDF},
  keywords = {Complex network; Adjacency matrix; Neighborhood structure; Monte Carlo
	method},
  owner = {rodrigo},
  review = {= Resumo =
	
	
	O artigo propõe uma métrica de distância entre duas redes com o mesmo
	número de vértices. Essa métrica é usada no artigo para comparar
	diversos modelos generativos de redes.
	
	
	= Impressões =
	
	
	Artigo muito bem escrito!
	
	
	Essa idéia de distância pode ser usada para medir a distância de duas
	versões de um software. Consideramos na segunda versão apenas os
	vértices que já existiam na primeira.
	
	
	O artigo diz que a distância entre redes detecta diferenças locais
	que não são reveladas por comparação de propriedades geométricas
	globais (coeficiente de clustering, diâmetro, grau médio...)
	
	
	Essa distância entre redes é baseada na idéia de distância mínima
	entre vértices. E eu tenho a intuição que distância entre vértices
	não tem um significado bem definido no caso de redes de software.
	
	
	Dá pra pensar em distância entre redes baseada em outras métricas
	como coeficiente de clustering de um vértice (que é uma métrica sobre
	um vértice). Mas será que existe uma métrica que relacione dois vértices,
	sem ser distância, que é mais adequada para meu projeto? Talvez shared
	neighbors, ou ainda shared neighbors estendendo a noção de neighbors
	para vizinhos de alta ordem (vertices cuja distância é l, 1 <= l
	<= D, D é o diâmetro). Ou ainda a distância l para a qual os dois
	vértices possuem pelo menos m shared neighbors.},
  timestamp = {2009.02.11}
}

@ARTICLE{Barabasi2007,
  author = {Albert-Laszlo Barabasi},
  title = {The Architecture of Complexity: From Network Structure to Human Dynamics},
  journal = {Control Systems Magazine, IEEE},
  year = {2007},
  volume = {27},
  pages = {33--42},
  month = {August},
  doi = {10.1109/MCS.2007.384127},
  owner = {rodrigo},
  review = {The purpose of this article is to illustrate, through the example
	of human dynamics, that a thorough understanding of complex systems
	requires an understanding of network dynamics as well as network
	topology and architecture. After an overview of the topology of complex
	networks, such as the Internet and the WWW, data-driven models for
	human dynamics are given. These models motivate the study of network
	dynamics and suggest that complexity theory must incorporate the
	interactions between dynamics and structure. The article also advances
	the notion that an understanding of network dynamics is facilitated
	by the availability of large data sets and analysis tools gained
	from the study of network structure.},
  timestamp = {2009.04.15}
}

@ARTICLE{Barabasi1999,
  author = {Albert-Laszlo Barabasi and Reka Albert},
  title = {Emergence of scaling in random networks},
  journal = {Science},
  year = {1999},
  volume = {286},
  pages = {509},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/9910332}
}

@BOOK{Linked,
  title = {Linked: How Everything Is Connected to Everything Else and What It
	Means for Business, Science, and Everyday Life},
  publisher = {{Plume Books}},
  year = {2003},
  author = {Barabási, Albert-László},
  month = {April},
  abstract = {{A cocktail party. A terrorist cell. Ancient bacteria. An international
	conglomerate. <br><br> All are networks, and all are a part of a
	surprising scientific revolution. Albert-L\&aacuteszl\&oacute Barab\&aacutesi,
	the nation's foremost expert in the new science of networks, takes
	us on an intellectual adventure to prove that social networks, corporations,
	and living organisms are more similar than previously thought. Grasping
	a full understanding of network science will someday allow us to
	design blue-chip businesses, stop the outbreak of deadly diseases,
	and influence the exchange of ideas and information. Just as James
	Gleick brought the discovery of chaos theory to the general public,
	Linked tells the story of the true science of the future.}},
  citeulike-article-id = {105595},
  howpublished = {Paperback},
  isbn = {0452284392},
  keywords = {barabasi, book, linked, networks},
  posted-at = {2005-06-15 14:14:01},
  priority = {0},
  url = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0452284392}
}

@ARTICLE{Barabasi2003,
  author = {Albert-László Barabási and Eric Bonabeau},
  title = {Scale-Free Networks},
  journal = {Scientific American},
  year = {2003},
  pages = {50-59},
  month = {Mai},
  biburl = {http://www.bibsonomy.org/bibtex/2c05be45be07a46e34bf0674f3dda700e/sosbuch},
  entrytype = {article},
  file = {Barabasi e Bonabeau - Scale-Free Networks (Scientific American) (2003).pdf:artigos/Barabasi
	e Bonabeau - Scale-Free Networks (Scientific American) (2003).pdf:PDF;Deo
	et al - A Birth-death Dynamic Model of Scale-free Networks (2005).pdf:artigos/Deo
	et al - A Birth-death Dynamic Model of Scale-free Networks (2005).pdf:PDF;Valverde
	et al - Scale-free Networks from Optimal Design (2002).pdf:artigos/Valverde
	et al - Scale-free Networks from Optimal Design (2002).pdf:PDF;Barabasi
	et al - Determinist Scale-Free Networks.pdf:misc-artigos/Barabasi
	et al - Determinist Scale-Free Networks.pdf:PDF;Wu et al - Mining
	Scale-free Networks using Geodesic Clustering (2004).pdf:Para categorizar/Wu
	et al - Mining Scale-free Networks using Geodesic Clustering (2004).pdf:PDF},
  keywords = {imported }
}

@ARTICLE{Baxter2006,
  author = {Gareth Baxter and Marcus Frean and James Noble and Mark Rickerby
	and Hayden Smith and Matt Visser and Hayden Melton and Ewan Tempero},
  title = {Understanding the shape of Java software},
  journal = {SIGPLAN Not.},
  year = {2006},
  volume = {41},
  pages = {397--412},
  number = {10},
  abstract = {Large amounts of Java software have been written since the language's
	escape into unsuspecting software ecology more than ten years ago.
	Surprisingly little is known about the structure of Java programs
	in the wild: about the way methods are grouped into classes and then
	into packages, the way packages relate to each other, or the way
	inheritance and composition are used to put these programs together.
	We present the results of the first in-depth study of the structure
	of Java programs. We have collected a number of Java programs and
	measured their key structural attributes. We have found evidence
	that some relationships follow power-laws, while others do not. We
	have also observed variations that seem related to some characteristic
	of the application itself. This study provides important information
	for researchers who can investigate how and why the structural relationships
	we find may have originated, what they portend, and how they can
	be managed.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1167515.1167507},
  file = {Baxter et al - Understanding the Shape of Java Software (2006).pdf:artigos/Baxter
	et al - Understanding the Shape of Java Software (2006).pdf:PDF},
  issn = {0362-1340},
  publisher = {ACM},
  review = {= Revisão =
	
	
	O estudo envolve 56 aplicações escritas em Java e se propõe a reproduzir
	de forma mais extensiva o trabalho de Wheeldon e Counsell.
	
	
	Os autores sugerem que métricas as quais os programadores possuem
	alguma noção possuem um cutoff na distribuição (veja citação)
	
	
	= Citações =
	
	
	This suggests that ‘C’ relationships are more likely than ‘P’ relationships
	to have ‘truncated’ curves. We can generalise this to hypothesise
	that any metric that measures something that the programmer is inherently
	aware of will tend to have a ‘truncated’ curve, that is, not be a
	power-law. (p. 11)
	
	(nota: relações C têm a ver com grau de saída e P, com grau de entrada.)
	
	
	There is quite noticeable variation on the degree of fit between different
	applications.
	
	
	= Crítica =
	
	
	Bom tratamento estatístico. Fornece equações para lognormal e stretched
	exponential.
	
	
	Leitura complicada...}
}

@INPROCEEDINGS{Bollobas2003,
  author = {Béla Bollobás and Christian Borgs and Jennifer Chayes and Oliver
	Riordan},
  title = {Directed scale-free graphs},
  booktitle = {SODA '03: Proceedings of the fourteenth annual ACM-SIAM symposium
	on Discrete algorithms},
  year = {2003},
  pages = {132--139},
  address = {Philadelphia, PA, USA},
  publisher = {Society for Industrial and Applied Mathematics},
  file = {Bollobas et al - Directed Scale-Free Graphs.pdf:artigos/Bollobas et
	al - Directed Scale-Free Graphs.pdf:PDF},
  isbn = {0-89871-538-5},
  location = {Baltimore, Maryland},
  owner = {rodrigo},
  review = {O artigo introduz um modelo para grafos orientados livres de escala
	que crescem com preferential attachment.
	
	A cada passo, o grafo pode ser modificado adicionando-lhe um vértice
	(que é ligado a um vértice existente) ou uma aresta entre dois vértices
	pré-existentes.
	
	Os autores fornecem demonstrações formais de que o modelo gera um
	grafo livre de escala.
	
	Por fim, são fornecidos parâmetros para o modelo que geram grafos
	semelhantes à estrutura da web.
	
	
	A meu ver, esse modelo possui duas vantagens em relação ao modelo
	de Barabasi-Albert:
	
	1) O grau de saída não é fixo.
	
	2) As novas arestas podem ligar vértices nos primeiros passos.
	
	
	No entanto, existem limitações:
	
	1) Não há remoção de arestas
	
	2) Não há remoção de vértices
	
	
	-- Rodrigo, 19/11/2008},
  timestamp = {2008.11.19}
}

@MISC{Challet2003,
  author = {Damien Challet and Andrea Lombardoni},
  title = {Bug propagation and debugging in asymmetric software structures},
  year = {2003},
  abstract = {Software dependence networks are shown to be scale-free and asymmetric.
	We then study how software components are affected by the failure
	of one of them, and the inverse problem of locating the faulty component.
	Software at all levels is fragile with respect to the failure of
	a random single component. Locating a faulty component is easy if
	the failures only affect their nearest neighbors, while it is hard
	if the failures propagate further.},
  file = {Challet et al - Bug propagation and debugging in asymmetric software
	structures (2003).pdf:artigos/Challet et al - Bug propagation and
	debugging in asymmetric software structures (2003).pdf:PDF},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0306509}
}

@INPROCEEDINGS{Chatzigeorgiou2006,
  author = {Alexander Chatzigeorgiou and Nikolaos Tsantalis and George Stephanides},
  title = {Application of graph theory to OO software engineering},
  booktitle = {WISER '06: Proceedings of the 2006 international workshop on Workshop
	on interdisciplinary software engineering research},
  year = {2006},
  pages = {29--36},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1137661.1137669},
  file = {Chatzigeorgiou - Application of Graph Theory to OO Software Engineering
	(2006).pdf:artigos/Chatzigeorgiou - Application of Graph Theory to
	OO Software Engineering (2006).pdf:PDF},
  isbn = {1-59593-409-X},
  location = {Shanghai, China}
}

@ARTICLE{Chen2008,
  author = {Tao Chen and Qing Gu and Shusen Wang and Xiaoan Chen and Daoxu Chen},
  title = {Module-based large-scale software evolution based on complex networks},
  journal = {8th IEEE International Conference on Computer and Information Technology},
  year = {2008},
  pages = {798---803},
  abstract = {Large-scale software systems usually consist of a huge number of modules,
	and have a series of releases along with these modules. This can
	be seen as software evolution. In recent years, researchers have
	put forward several models of software evolution by employing the
	theory of complex networks. In this paper, we put forward a refined
	model of software evolution based on the BA model: module-based evolution.
	We theoretically prove that the power-law degree distribution can
	be held in our model. We also build a tool to construct and analyze
	the class diagrams of JDK (Java Development Kits) evolved from version
	1.2 to 1.6. The class diagrams can be seen as complex networks under
	evolution. We apply the module-based evolution model to these complex
	networks and simulate the evolution of key network features such
	as average clustering coefficient and average path length. Compared
	with real networks, our model can precisely describe the evolution
	of these features, and be used to help developers understand the
	characteristics of large-scale software evolution.},
  owner = {rodrigo},
  review = {= Resumo =
	
	
	O artigo propõe um modelo evolutivo de rede de software baseado no
	modelo de Barabási-Albert e considerado a organização da rede em
	módulos. Nesse modelo a ligação preferencial é expandida com um parâmetro,
	alfa, que determina até que ponto um vértice se liga preferencialmente
	a vértices do mesmo módulo. A probabilidade de se escolher um vértice
	é denotada por pi_a. O número de módulos é um parâmetro, M. A cada
	iteração do algoritmo é executado um dos seguintes eventos:
	
	
	Evento 1: Com probabilidade p1 adiciona um vértice com e1 arestas,
	que é atribuído a um módulo escolhido aleatoriamente. As extremidades
	livres das arestas são ligadas a vértices escolhidos de acordo com
	a pi_a.
	
	
	Evento 2: Com probabilidade p2 são adicionados e2 arestas. Para cada
	aresta, uma extremidade é selecionada aleatoriamente e a outra é
	selecionada de acordo com pi_a.
	
	
	Evento 3: Com probabilidade p3 são religadas e3 arestas. A cada vez
	é escolhido um vértice aleatoriamente e uma de suas arestas é religa
	para um vértice escolhido de acordo com pi_a.
	
	
	Evento 4: Com probabilidade p4 são removidos e4 arestas escolhidas
	aleatoriamente. 
	
	
	Quando se refere a grau, o modelo quer dizer grau de entrada.
	
	
	Os autores provam analiticamente que a distribuição dos graus de entrada
	é livre de escala e fornece uma equação para determinar o expoente
	da distribuição a partir dos parâmetros.
	
	
	Com a finalidade de avaliar empiricamente o modelo, os autores consideram
	5 versões do JDK e extraem os deltas entre as versões: número de
	novos vértices e número de novas arestas. Eles consideram p3 = p4
	= 0 e então determinam os parâmetros do modelo para cada evolução
	do JDK. Eles validam as redes sintéticas comparando com as redes
	reais algumas métricas: número de arestas, coeficiente de clustering
	médio, comprimento do caminho médio e coeficiente da distribuição
	de graus de entrada.
	
	
	= Crítica =
	
	
	A rede de ligações entre módulos é potencialmente um grafo completo.
	
	
	Os resultados do experimento com o JDK não são contundentes.},
  timestamp = {2009.05.18}
}

@ARTICLE{Clauset2008,
  author = {Clauset, Aaron and Moore, Cristopher and Newman, M. E. J. },
  title = {Hierarchical structure and the prediction of missing links in networks},
  journal = {Nature},
  year = {2008},
  volume = {453},
  pages = {98--101},
  number = {7191},
  citeulike-article-id = {2739852},
  doi = {http://dx.doi.org/10.1038/nature06830},
  file = {Clauset et al - Hierarchical structure and the prediction of missing
	links in networks (2008).pdf:artigos/Clauset et al - Hierarchical
	structure and the prediction of missing links in networks (2008).pdf:PDF},
  issn = {0028-0836},
  keywords = {graph, hierarchy},
  posted-at = {2008-05-04 00:44:20},
  priority = {5},
  publisher = {Nature Publishing Group},
  url = {http://dx.doi.org/10.1038/nature06830}
}

@MISC{Clauset2006,
  author = {Aaron Clauset and Cristopher Moore and M.~E.~J. Newman},
  title = {Structural Inference of Hierarchies in Networks},
  year = {2006},
  note = {Algoritmo de clustering não-determinístico, baseado em maximização
	do likelihood através de Markov Chain Monte Carlo sampling},
  abstract = {One property of networks that has received comparatively little attention
	is hierarchy, i.e., the property of having vertices that cluster
	together in groups, which then join to form groups of groups, and
	so forth, up through all levels of organization in the network. Here,
	we give a precise definition of hierarchical structure, give a generic
	model for generating arbitrary hierarchical structure in a random
	graph, and describe a statistically principled way to learn the set
	of hierarchical features that most plausibly explain a particular
	real-world network. By applying this approach to two example networks,
	we demonstrate its advantages for the interpretation of network data,
	the annotation of graphs with edge, vertex and community properties,
	and the generation of generic null models for further hypothesis
	testing.},
  file = {Clauset et al - Structural Inference of Hierarchies in Networks (2006).pdf:artigos/Clauset
	et al - Structural Inference of Hierarchies in Networks (2006).pdf:PDF},
  url = {doi:10.1007/978-3-540-73133-7_1}
}

@ARTICLE{Clauset2004,
  author = {Aaron Clauset and M.~E.~J. Newman and Cristopher Moore},
  title = {Finding community structure in very large networks},
  journal = {Physical Review E},
  year = {2004},
  volume = {70},
  pages = {066111},
  url = {doi:10.1103/PhysRevE.70.066111}
}

@MISC{Clauset2007,
  author = {Aaron Clauset and Cosma Rohilla Shalizi and M.~E.~J. Newman},
  title = {Power-law distributions in empirical data},
  year = {2007},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:0706.1062}
}

@ARTICLE{Concas2007,
  author = {Concas, Giulio and Marchesi, Michele and Pinna, Sandro and Serra,
	Nicola},
  title = {Power-Laws in a Large Object-Oriented Software System},
  journal = IEEE_J_SE,
  year = {2007},
  volume = {33},
  pages = {687--708},
  number = {10},
  abstract = {We present a comprehensive study of an implementation of the Smalltalk
	object oriented system, one of the first and purest object-oriented
	programming environment, searching for scaling laws in its properties.
	We study ten system properties, including the distributions of variable
	and method names, inheritance hierarchies, class and method sizes,
	system architecture graph. We systematically found Pareto - or sometimes
	log-normal - distributions in these properties. This denotes that
	the programming activity, even when modeled from a statistical perspective,
	can in no way be simply modeled as a random addition of independent
	increments with finite variance, but exhibits strong organic dependencies
	on what has been already developed. We compare our results with similar
	ones obtained for large Java systems, reported in the literature
	or computed by ourselves for those properties never studied before,
	showing that the behavior found is similar in all studied object
	oriented systems. We show how the Yule process is able to stochastically
	model the generation of several of the power-laws found, identifying
	the process parameters and comparing theoretical and empirical tail
	indexes. Lastly, we discuss how the distributions found are related
	to existing object-oriented metrics, like Chidamber and Kemerer's,
	and how they could provide a starting point for measuring the quality
	of a whole system, versus that of single classes. In fact, the usual
	evaluation of systems based on mean and standard deviation of metrics
	can be misleading. It is more interesting to measure differences
	in the shape and coefficients of the data?s statistical distributions.},
  doi = {10.1109/TSE.2007.1019},
  file = {Concas et al - Power-Laws in a Large Object-Oriented Software System
	(2007).pdf:artigos/Concas et al - Power-Laws in a Large Object-Oriented
	Software System (2007).pdf:PDF},
  issn = {0098-5589},
  keywords = {D.2.3.a Object-oriented programming, D.2.4.h Statistical methods,
	D.2.8.a Complexity measures, D.2.8.d Product metrics, D.2.8.e Software
	science, D.3.2.p Object-oriented languages, G.3.p Stochastic processes},
  owner = {rodrigo},
  review = {= Revisão =
	
	
	O artigo computa diversas métricas a partir da análise dos sistemas
	Smalltalk, JDK e Eclipse. As distribuições estatísticas dessas métricas
	seguem consistententemente distribuições de Pareto ou log-normal.
	
	
	Os autores sugerem que não faz sentido calcular a média e o desvio-padrão
	de métricas de software, uma vez que muitas delas seguem distribuições
	de cauda gorda (fat tail). Eles propõem média e expoente da cauda.
	
	
	== Correlações entre métricas ==
	
	
	Sistema estudado: Smalltalk.
	
	
	LOC X out-degree: 0.97
	
	Number of methods X LOC: 0.83
	
	Number of methods X out-degree: 0.79
	
	Number of subclasses X in-degree: 0.80
	
	
	== Distribuições ==
	
	
	Sistemas estudados: Smalltalk e, às vezes, JDK e Eclipse.
	
	http://en.wikipedia.org/wiki/Pearson%27s_chi-square_test
	
	
	Número de métodos por classe: log-normal.
	
	Número total de atributos uma classe (atributos imediatos + atributos
	herdados): log-normal.
	
	Número de subclasses por classe: power law.
	
	Freqüência de instance variable and method names: power law.
	
	Número de chamadas a um método: power law.
	
	Linhas de código por classe: log-normal. (good fit)
	
	In-degree: power law.
	
	Out-degree: log-normal (obs.: out-degree tem correlação com LOC).
	
	
	= Citações =
	
	
	In fact, the usual evaluation of systems based on mean and standard
	deviation of metrics can be misleading. It is more interesting to
	measure differences in the shape and coefficients of the data’s statistical
	distributions. (abstract)
	
	
	(...) a full statistical model of software production is a task never
	accomplished before and is obviously beyond the scope of this paper.
	(p. 2)
	
	
	* Random and proportional. The entity to be changed is chosen randomly
	as before, but the size of the increment is proportional to its present
	value. This model leads to log-normal distributions of properties,
	which semms to be a much more frequent case in real software systems.
	(p. 6)
	
	
	Interestingly, if deletion is performed proportionally to the current
	value of the properties, exactly like addition, and if deletions
	are made at a lower rate than additions, GPA demonstrates that the
	overall process is still a Yule process.
	
	
	This means that the log-normal or power-law behavior found in the
	out-links distribution by other authors is an artifact. They, in
	fact, measured the log-normal (or power-law) distribution of class
	sizes. (p. 17)
	
	
	= Crítica =
	
	
	O artigo apresenta uma boa base estatística.},
  timestamp = {2008.11.15}
}

@INPROCEEDINGS{Deo2005,
  author = {Narsingh Deo and Aurel Cami},
  title = {A birth-death dynamic model of scale-free networks},
  booktitle = {ACM-SE 43: Proceedings of the 43rd annual Southeast regional conference},
  year = {2005},
  pages = {26--27},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1167253.1167260},
  file = {Deo et al - A Birth-death Dynamic Model of Scale-free Networks (2005).pdf:artigos/Deo
	et al - A Birth-death Dynamic Model of Scale-free Networks (2005).pdf:PDF},
  isbn = {1-59593-059-0},
  location = {Kennesaw, Georgia}
}

@ARTICLE{Dorogovtsev2002,
  author = {S.~N. Dorogovtsev and A.~V. Goltsev and J.~F.~F. Mendes},
  title = {Pseudofractal Scale-free Web},
  journal = {Physical Review E},
  year = {2002},
  volume = {65},
  pages = {066122},
  note = {Citado por Myers, Barabási},
  abstract = {We find that scale-free random networks are excellently modeled by
	a deterministic graph. This graph has a discrete degree distribution
	(degree is the number of connections of a vertex) which is characterized
	by a power-law with exponent γ=1+łn3/łn2. Properties of this simple
	structure are surprisingly close to those of growing random scale-free
	networks with γ in the most interesting region, between 2 and 3.
	We succeed to find exactly and numerically with high precision all
	main characteristics of the graph. In particular, we obtain the exact
	shortest-path-length distribution. For the large network (łn N gg
	1) the distribution tends to a Gaussian of width ∼ √łn N centered
	at ell ∼ łn N. We show that the eigenvalue spectrum of the adjacency
	matrix of the graph has a power-law tail with exponent 2+γ.},
  comment = {5 pages, 3 figures},
  file = {Dorogovtsev, Goltsev, Mendes - Pseudofractal Scale-free Web (2001).pdf:artigos/Dorogovtsev,
	Goltsev, Mendes - Pseudofractal Scale-free Web (2001).pdf:PDF},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0112143}
}

@MISC{Drappa2000,
  author = {Drappa, A. and Ludewig, J.},
  title = {Simulation in software engineering training},
  year = {2000},
  doi = {10.1109/ICSE.2000.870411},
  file = {Drappa et al - Simulation in software engineering training (2000).pdf:artigos/Drappa
	et al - Simulation in software engineering training (2000).pdf:PDF},
  journal = {Software Engineering, 2000. Proceedings of the 2000 International
	Conference on},
  keywords = {computer based training, computer science education, digital simulation,
	project management, software development management, teachingQA model,
	SESAM project, application areas, future work, model behavior, quick-motion
	mode, simulated software project, simulation model, software development,
	software engineering education, software engineering training, software
	project manager, student},
  pages = {199-208}
}

@MISC{Eppstein2002,
  author = {David Eppstein and Joseph Wang},
  title = {A steady state model for graph power laws},
  year = {2002},
  note = {algoritmo implementado pela API JUNG},
  abstract = {Power law distribution seems to be an important characteristic of
	web graphs. Several existing web graph models generate power law
	graphs by adding new vertices and non-uniform edge connectivities
	to existing graphs. Researchers have conjectured that preferential
	connectivity and incremental growth are both required for the power
	law distribution. In this paper, we propose a different web graph
	model with power law distribution that does not require incremental
	growth. We also provide a comparison of our model with several others
	in their ability to predict web graph clustering behavior.},
  timestamp = {2009.02.18},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cs/0204001}
}

@ARTICLE{Erdos1959,
  author = {Erd\"{o}s, P. and R\'{e}nyi, A. },
  title = {On random graphs, I},
  journal = {Publicationes Mathematicae (Debrecen)},
  year = {1959},
  volume = {6},
  pages = {290--297},
  citeulike-article-id = {4012374},
  keywords = {graphs, random},
  posted-at = {2009-02-28 00:47:14},
  priority = {2},
  url = {http://www.renyi.hu/\~{}p\_erdos/Erdos.html\#1959-11}
}

@ARTICLE{Fagiolo2006,
  author = {Giorgio Fagiolo},
  title = {Clustering in Complex Directed Networks},
  year = {2006},
  abstract = {Many empirical networks display an inherent tendency to cluster, i.e.
	to form circles of connected nodes. This feature is typically measured
	by the clustering coefficient (CC). The CC, originally introduced
	for binary, undirected graphs, has been recently generalized to weighted,
	undirected networks. Here we extend the CC to the case of (binary
	and weighted) directed networks and we compute its expected value
	for random graphs. We distinguish between CCs that count all directed
	triangles in the graph (independently of the direction of their edges)
	and CCs that only consider particular types of directed triangles
	(e.g., cycles). The main concepts are illustrated by employing empirical
	data on world-trade flows.},
  owner = {rodrigo},
  timestamp = {2009.02.12},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:physics/0612169}
}

@ARTICLE{Fu2006,
  author = {Peihua Fu and Kun Liao},
  title = {An Evolving Scale-free Network with Large Clustering Coefficient},
  journal = {Control, Automation, Robotics and Vision, 2006. ICARCV '06. 9th International
	Conference on},
  year = {2006},
  pages = {1-4},
  month = {Dec.},
  note = {Relatively Preferential Attachment (RPA)},
  abstract = {Preferential attachment is generally regarded as the best mechanism
	to form scale-free networks. However, the simulated network has a
	much smaller clustering coefficient, while many networks in the real
	world, such as movie actors' collaboration and co-authorship networks,
	have a high clustering coefficient. So we develop the relatively
	preferential attachment (RPA) method which considers preferential
	attachment as well as the probability channel. RPA model can produce
	networks which not only keep the scale free property but also have
	high clustering coefficient close to those of real networks},
  doi = {10.1109/ICARCV.2006.345053},
  file = {Fu et al - An Evolving Scale-free Network with Large Clustering Coefficient
	(2006).pdf:artigos/Fu et al - An Evolving Scale-free Network with
	Large Clustering Coefficient (2006).pdf:PDF},
  keywords = {computer networks, probabilityclustering coefficient, evolving scale-free
	network, probability channel, relatively preferential attachment},
  owner = {rodrigo},
  timestamp = {2009.01.11}
}

@MISC{Gulbahce2008,
  author = {Natali Gulbahce and Sune Lehmann},
  title = {The art of community detection},
  year = {2008},
  abstract = {Networks in nature possess a remarkable amount of structure. Via a
	series of data-driven discoveries, the cutting edge of network science
	has recently progressed from positing that the random graphs of mathematical
	graph theory might accurately describe real networks to the current
	viewpoint that networks in nature are highly complex and structured
	entities. The identification of high order structures in networks
	unveils insights into their functional organization. Recently, Clauset,
	Moore, and Newman, introduced a new algorithm that identifies such
	heterogeneities in complex networks by utilizing the hierarchy that
	necessarily organizes the many levels of structure. Here, we anchor
	their algorithm in a general community detection framework and discuss
	the future of community detection.},
  owner = {rodrigo},
  review = {= Citações =
	
	
	Currently the state of the art is to design an artificial network
	with the structural properties that one wants to detect (e.g. group
	strucutre) and then show that the algorithm being tested is able
	to detect such structures.
	
	
	It is possible to artificially remove (or add) links from a real network
	and measure how well the algorithm under study is able to accurately
	determine robust community structure. (cita "Robustness of community
	structure in networks")},
  timestamp = {2009.03.02},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:0807.1833}
}

@INCOLLECTION{Han2006,
  author = {Han, Jie and Yu, Yong and Lin, Chenxi and Han, Dingyi and Xue, Gui-Rong
	},
  title = {A Hierarchical Model of Web Graph},
  year = {2006},
  pages = {790--797},
  abstract = {The pages on the World Wide Web and their hyperlinks induce a huge
	directed graph – the Web Graph. Many models have been brought up
	to explain the static and dynamic properties of the graph. Most of
	them pay much attention to the pages without considering their essential
	relations. In fact, Web pages are well organized in Web sites as
	a tree hierarchy. In this paper, we propose a hierarchical model
	of Web graph which exploits both link structure and hierarchical
	relations of Web pages. The analysis of the model reveals many properties
	about the evolution of pages, sites and the relation among them.},
  citeulike-article-id = {2568611},
  doi = {http://dx.doi.org/10.1007/11811305\_86},
  file = {Han et al - A Hierarchical Model of Web Graph (2006).pdf:artigos/Han
	et al - A Hierarchical Model of Web Graph (2006).pdf:PDF},
  journal = {Advanced Data Mining and Applications},
  keywords = {web},
  posted-at = {2008-03-21 03:59:41},
  priority = {2},
  url = {http://dx.doi.org/10.1007/11811305\_86}
}

@MISC{Hazelhurst2003,
  author = {Scott Hazelhurst and Anton Bergheim},
  title = {Introduction ESTSim: A tool for creating benchmarks for EST clustering
	algorithms},
  year = {2003},
  owner = {rodrigo},
  review = {= Citações =
	
	
	In summary, the best benchmarks for testing new clustering algorithms
	are data sets described in (1) [expert comparison] above. Testing
	the quality of new algorithms by comparing them to existing algorithms
	is attractive, but flawed. Since benchmarks of the form described
	in (1) above are very rare, we need to look at complementary techniques.
	(p. 2)
	
	
	We propose that artificial but realistic data sets should be used
	as complementary benchmarks
	
	
	The objective of ESTsim is to produce large amounts of artificial
	– but realistic – test data for testing the effectiveness of different
	distance measures used in clustering DNA (or related sequences).
	
	
	The artificial creation of ESTs in this way will lead to the creation
	of an EST set whose exact final clustering is known. So, when testing
	a new algorithm or measure, we can compare the output of the new
	algorithm with the known right answer.
	
	
	In addition, the use of artificial test data enables us to produce
	data with a range of different error models. Thus, if some measures
	are better than other measures in different circumstances we will
	be able to provide some insight. This would be difficult to test
	with real data.
	
	
	In summary we propose that as well as testing on real data, testing
	on artificial data would be very useful.
	
	
	The methodology used was to try to understand the biological processes
	and with the aid of a biologist draw the types of error curves. We
	then found convenient mathematical functions that simulated these
	curves and that could be easily programmed. (p. 3)},
  timestamp = {2009.02.14}
}

@INPROCEEDINGS{Herraiz2007,
  author = {Herraiz,, Israel and Gonzalez-Barahona,, Jesus M. and Robles,, Gregorio},
  title = {Towards a Theoretical Model for Software Growth},
  booktitle = {MSR '07: Proceedings of the Fourth International Workshop on Mining
	Software Repositories},
  year = {2007},
  pages = {21},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  doi = {http://dx.doi.org/10.1109/MSR.2007.31},
  isbn = {0-7695-2950-X},
  review = {= Resumo =
	
	
	Esse artigo estuda cerca de 700 mil arquivos fonte na linguagem C
	tirados do FreeBSD Ports e calcula, para cada um deles, diversas
	métricas de tamanho -- SLOC, LOC, número de funções, úmero de linhas
	de comentário, número de comentários e número de linhas em branco
	-- e complexidade -- complexidade ciclomática, número de retornos
	de função e quatro métricas de Halstead.
	
	
	O estudo encontrou distribuições double Pareto para todas as métricas
	consideradas e uma alta correlação entre quaisquer duas delas.
	
	
	= Comentário =
	
	
	O tratamento estatístico do artigo usa a regra do três sigma para
	remover outliers e usa quantile-quantile (q-q) plots para comparar
	os dados com distribuições teóricas. Através de q-q plots os autores
	constataram que o logaritmo dos dados se aproxima da curva normal,
	exceto nos valores extremos, o que revela uma distribuição de double
	Pareto: as caudas inferiores e superiores são power laws e o corpo
	da distribuição é lognormal.
	
	
	= Crítica =
	
	
	Os autores poderiam usar maximum likelihood estimation para estimar
	os parâmetros das distribuições double Pareto (se é que existe um
	estimador para essa distribuição). Eles também poderiam ter usado
	o teste de Kolmogorov–Smirnov como um teste goodness of fit para
	poderem afirmar com mais força que os dados encontrados se encaixam
	na distribuição double Pareto.}
}

@INPROCEEDINGS{Hyland-Wood2006,
  author = {David Hyland-Wood and David Carrington and Simon Kaplan},
  title = {Scale-Free Nature of Java Software Package, Class and Method Collaboration
	Graphs},
  booktitle = {Proceedings of the 5th International Symposium on Empirical Software
	Engineering, Rio de Janeiro, Brasil},
  year = {2006},
  file = {Hyland-Wood et al - Scale-Free Nature of Java Software Package, Class
	and Method Collaboration Graphs (2006).pdf:artigos/Hyland-Wood et
	al - Scale-Free Nature of Java Software Package, Class and Method
	Collaboration Graphs (2006).pdf:PDF},
  organisation = {ACM}
}

@INPROCEEDINGS{Ichii2008,
  author = {Ichii, M. and Matsushita, M. and Inoue, K. },
  title = {An Exploration of Power-Law in Use-Relation of Java Software Systems},
  booktitle = {Proc. 19th Australian Conference on Software Engineering ASWEC 2008},
  year = {2008},
  pages = {422--431},
  abstract = {A software component graph, where a node represents a component and
	an edge represents a use-relation between components, is widely used
	for analysis methods of software engineering. It is said that a graph
	is characterized by its degree distribution. In this paper, we investigate
	software component graphs composed of Java classes, to seek whether
	the degree distribution follows so-called the power-law, which is
	a fundamental characteristic of various kinds of graphs in different
	fields. We found that the in-degree distribution follows the power-law
	and the out-degree distribution does not follow the power-law. In
	a software component graph with about 180 thousand components, just
	a few of the components have more than ten thousand in-degrees while
	most of the components have only one or zero in-degree.},
  doi = {10.1109/ASWEC.2008.4483231},
  file = {Ichii et al - An Exploration of Power-law in Use-relation of Java
	Software Systems.pdf:artigos/Ichii et al - An Exploration of Power-law
	in Use-relation of Java Software Systems.pdf:PDF},
  issn = {1530-0803},
  keywords = {Java, object-oriented programming, software reusability, Java class,
	Java software system, degree distribution, power-law, software component
	graph, software engineering, Degree Distribution, Power-law, Scale-free
	Network, Software Component Graph},
  owner = {rodrigo},
  review = {= Revisão =
	
	
	Analisa vários sistemas escritos em Java. Os vértices são classes
	ou interfaces e as arestas são relações extends, implements, declara
	variável/membro/parâmetro, acessa variável, chama método, instancia
	objeto.
	
	
	Calcula distribuição de graus para a) sistemas de software, b) conjuntos
	de sistemas de software que dependem entre si e c) subconjuntos de
	um sistema de software escolhidos i) aleatoriamente, ii) a partir
	de um elemento pivô ou iii) a partir de uma palavra chave.
	
	
	Em todos os casos percebe-se power law no in-degree mas não no out-degree.
	Ele sugere que o out-degree segue uma distribuição double pareto
	(a cauda é muito pesada para ser lognormal), mas afirma que é preciso
	investigar mais.
	
	
	Adicionalmente, há uma correlação entre out-degree e métricas de complexidade
	(WMC) e tamanho (LOC).
	
	
	Cita vários trabalhos que o precederam.
	
	
	Usa o SPARS-J para calcular métricas e relacionamentos entre classes/interfaces.
	
	
	= Citações =
	
	
	We believe that it is possible to detect the changes of the software
	architecture, or to measure its stability by watching the changes
	of the set of the components which have the large in-degree. (p.
	8)},
  timestamp = {2008.11.15}
}

@INPROCEEDINGS{Kumar2000,
  author = {R. Kumar and P. Raghavan and S. Rajagopalan and D. Sivakumar and
	A. Tomkins and E. Upfal},
  title = {Stochastic models for the Web graph},
  booktitle = {FOCS '00: Proceedings of the 41st Annual Symposium on Foundations
	of Computer Science},
  year = {2000},
  pages = {57},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  note = {Copying model},
  file = {Kumar et al - Stochastic models for the web graph (copying model)
	(2000).pdf:artigos/Kumar et al - Stochastic models for the web graph
	(copying model) (2000).pdf:PDF},
  isbn = {0-7695-0850-2}
}

@MISC{Labelle2004,
  author = {Nathan LaBelle and Eugene Wallingford},
  title = {Inter-Package Dependency Networks in Open-Source Software},
  year = {2004},
  file = {LaBelle et al - Inter-Package Dependency Networks in Open-Source Software
	(2004).pdf:artigos/LaBelle et al - Inter-Package Dependency Networks
	in Open-Source Software (2004).pdf:PDF},
  review = {= Revisão =
	
	
	Os autores estudam dependências entre pacotes em dois repositórios
	de software livre: Debian GNU/Linux software repository e FreeBSD
	Ports Collection. Eles concluem que as redes estudadas são de mundo
	pequeno e a distribuição de graus segue a power law (embora não perfeitamente).
	
	
	= Crítica =
	
	
	Artigo pequeno com tratamento estatístico simplista.},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cs/0411096}
}

@ARTICLE{Lancichinetti2009,
  author = {Andrea Lancichinetti and Santo Fortunato},
  title = {Benchmarks for testing community detection algorithms on directed
	and weighted graphs with overlapping communities},
  year = {2009},
  abstract = {Many complex networks display a mesoscopic structure with groups of
	nodes sharing many links with the other nodes in their group and
	comparatively few with nodes of different groups. This feature is
	known as community structure and encodes precious information about
	the organization and the function of the nodes. Many algorithms have
	been proposed but it is not yet clear how they should be tested.
	Recently we have proposed a general class of undirected and unweighted
	benchmark graphs, with heterogenous distributions of node degree
	and community size. An increasing attention has been recently devoted
	to develop algorithms able to consider the direction and the weight
	of the links, which require suitable benchmark graphs for testing.
	In this paper we extend the basic ideas behind our previous benchmark
	to generate directed and weighted networks with built-in community
	structure. We also consider the possibility that nodes belong to
	more communities, a feature occurring in real systems, like, e. g.,
	social networks. As a practical application, we show how modularity
	optimization performs on our new benchmark.},
  owner = {rodrigo},
  timestamp = {2009.05.18},
  url = {http://arxiv.org/abs/0904.3940}
}

@ARTICLE{Lancichinetti2008,
  author = {Lancichinetti, Andrea and Fortunato, Santo and Radicchi, Filippo},
  title = {Benchmark graphs for testing community detection algorithms},
  journal = {Physical Review E (Statistical, Nonlinear, and Soft Matter Physics)},
  year = {2008},
  volume = {78},
  number = {4},
  abstract = {Community structure is one of the most important features of real
	networks and reveals the internal organization of the nodes. Many
	algorithms have been proposed but the crucial issue of testing, i.e.
	the question of how good an algorithm is, with respect to others,
	is still open. Standard tests include the analysis of simple artificial
	graphs with a built-in community structure, that the algorithm has
	to recover. However, the special graphs adopted in actual tests have
	a structure that does not reflect the real properties of nodes and
	communities found in real networks. Here we introduce a new class
	of benchmark graphs, that account for the heterogeneity in the distributions
	of node degrees and of community sizes. We use this new benchmark
	to test two popular methods of community detection, modularity optimization
	and Potts model clustering. The results show that the new benchmark
	poses a much more severe test to algorithms than standard benchmarks,
	revealing limits that may not be apparent at a first analysis.},
  citeulike-article-id = {3454707},
  posted-at = {2008-10-28 03:40:43},
  priority = {2},
  publisher = {APS},
  review = {= Citações =
	
	
	This race towards the ideal method [of community detection] aims at
	two main goals, i.e., improving the ACCURACY in the determination
	of meaningful modules and reducing the COMPUTATIONAL COMPLEXITY of
	the algorithm. (p. 1)
	
	
	Testing an algorithm essentially means analyzing a network with a
	well-defined community structure and recovering its communities.
	Ideally, one would like to have MANY INSTANCES of real networks whose
	MODULES are precise KNOWN, but this is unfortunately not the case.
	Therefore, the most extensive tests are performed on COMPUTER GENERATED
	networks, with a built-in community structure.
	
	
	In this paper we propose a realistic benchmark for community detection,
	that accounts for the heterogeneity of both degree and community
	size. Detecting communities on this class of graphs is a CHALLENGING
	task.
	
	
	= Crítica =
	
	
	O modelo que gera as redes com uma estrutura modular bem definida
	realmente é bom? Como podemos provar que ele é bom? 
	
	
	Me parece que esse conceito de clustering bom é muito dependente de
	domínio.
	
	
	Suponhamos que estamos interessados no conceito de módulo baseado
	em uma função objetivo global que encoraja ligações entre vértices
	de um módulo e desencoraja ligações entre vértices de módulos distintos
	(a métrica Modularization Quality do algoritmo Bunch). Quando o modelo
	gera uma rede, a estrutura de comunidades usada como referência realmente
	é a estrutura ótima? Como provar?
	
	
	Em suma, talvez o modelo beneficie uma noção de modularidade em prejuízo
	de outras.},
  timestamp = {2009.02.12},
  url = {http://scitation.aip.org/getabs/servlet/GetabsServlet?prog=normal\&id=PLEEE8000078000004046110000001\&idtype=cvips\&gifs=yes}
}

@ARTICLE{Li2008,
  author = {Huan Li and Beibei Huang and Jinhu Lu},
  title = {Dynamical evolution analysis of the object-oriented software systems},
  journal = {Evolutionary Computation, 2008. CEC 2008. (IEEE World Congress on
	Computational Intelligence). IEEE Congress on},
  year = {2008},
  pages = {3030-3035},
  month = {June},
  doi = {10.1109/CEC.2008.4631207},
  file = {Li et al - Dynamical Evolution Analysis of the Object-Oriented Software
	Systems (2008).pdf:artigos/Li et al - Dynamical Evolution Analysis
	of the Object-Oriented Software Systems (2008).pdf:PDF;Dynamical
	Evolution Analysis of the Object-Oriented Software Systems.pdf:misc-artigos/Dynamical
	Evolution Analysis of the Object-Oriented Software Systems.pdf:PDF},
  keywords = {evolutionary computation, object-oriented methods, software engineeringdynamical
	evolution analysis, maintenance cost reduction, object-oriented software
	systems, software engineering, software evolution, software systems
	development},
  review = {= Revisão =
	
	
	Analisa a evolução de algumas métricas ao longo de diferentes versões
	de diversos sistemas escritos em Java.
	
	
	= Crítica =
	
	
	Muito mal escrito!}
}

@MISC{Li2005,
  author = {Lun Li and David Alderson and Reiko Tanaka and John C. Doyle and
	Walter Willinger},
  title = {Towards a Theory of Scale-Free Graphs: Definition, Properties, and
	Implications (Extended Version)},
  year = {2005},
  abstract = {Although the ``scale-free'' literature is large and growing, it gives
	neither a precise definition of scale-free graphs nor rigorous proofs
	of many of their claimed properties. In fact, it is easily shown
	that the existing theory has many inherent contradictions and verifiably
	false claims. In this paper, we propose a new, mathematically precise,
	and structural definition of the extent to which a graph is scale-free,
	and prove a series of results that recover many of the claimed properties
	while suggesting the potential for a rich and interesting theory.
	With this definition, scale-free (or its opposite, scale-rich) is
	closely related to other structural graph properties such as various
	notions of self-similarity (or respectively, self-dissimilarity).
	Scale-free graphs are also shown to be the likely outcome of random
	construction processes, consistent with the heuristic definitions
	implicit in existing random graph approaches. Our approach clarifies
	much of the confusion surrounding the sensational qualitative claims
	in the scale-free literature, and offers rigorous and quantitative
	alternatives.},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0501169}
}

@INPROCEEDINGS{Lopez2004,
  author = {Luis Lopez-Fernandez and Gregorio Robles and Jesus M. Gonzalez-Barahona},
  title = {Applying Social Network Analysis to the Information in CVS Repositories},
  booktitle = {Proceedings 1st International Workshop on Mining Software Repositories},
  year = {2004},
  pages = {101--105},
  month = {May},
  abstract = {The huge quantities of data available in the CVS repositories of large,
	long-lived libre (free, open source) software projects, and the many
	interrelationships among those data offer opportunities for extracting
	large amounts of valuable information about their structure, evolution
	and internal processes. Unfortunately, the sheer volume of that information
	renders it almost unusable without applying methodologies which highlight
	the relevant information for a given aspect of the project. In this
	paper, we propose the use of a well known set of methodologies (social
	network analysis) for characterizing libre software projects, their
	evolution over time and their internal structure. In addition, we
	show how we have applied such methodologies to real cases, and extract
	some preliminary conclusions from that experience.},
  description = {analysing libre software projects with network analysis explains basic
	concepts of social network analysis},
  file = {Lopez et al - Applying Social Network Analysis to the Information
	in CVS Repositories (2004).pdf:artigos/Lopez et al - Applying Social
	Network Analysis to the Information in CVS Repositories (2004).pdf:PDF},
  keywords = {2004 analysis basic cvs msr networks }
}

@ARTICLE{Louridas2008,
  author = {Panagiotis Louridas and Diomidis Spinellis and Vasileios Vlachos},
  title = {Power laws in software},
  journal = {ACM Trans. Softw. Eng. Methodol.},
  year = {2008},
  volume = {18},
  pages = {1--26},
  number = {1},
  abstract = {A single statistical framework, comprising power law distributions
	and scale-free networks, seems to fit a wide variety of phenomena.
	There is evidence that power laws appear in software at the class
	and function level. We show that distributions with long, fat tails
	in software are much more pervasive than previously established,
	appearing at various levels of abstraction, in diverse systems and
	languages. The implications of this phenomenon cover various aspects
	of software engineering research and practice.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1391984.1391986},
  file = {Louridas et al - Power Laws in Software (2008).pdf:artigos/Louridas
	et al - Power Laws in Software (2008).pdf:PDF},
  issn = {1049-331X},
  publisher = {ACM},
  review = {= Revisão =
	
	
	Os autores analisam redes de dependências entre bibliotecas dinâmicas,
	pacotes FreeBSD, pacotes CPAN e classes de sistemas OO e encontram
	power laws na distribuição de graus de todas essas redes. Algumas
	distribuições não são bem power laws -- os autores conjecturam que
	sejam lognormal ou stretched exponential.
	
	
	Os autores citam trabalhos anteriores (p. 12, sec. 3.8) e procuram
	implicações de suas descobertas em tópicos como reuso, qualidade
	e otimização.
	
	
	= Citações =
	
	
	To avoid bias due to outliers, we worked with the complementary cumulative
	definition (2), in which outliers are subsumed, and then converted
	the results of the fit to the initial distribution.}
}

@ARTICLE{Luqi1990,
  author = {Luqi},
  title = {A Graph Model for Software Evolution},
  journal = {IEEE Trans. Softw. Eng.},
  year = {1990},
  volume = {16},
  pages = {917--927},
  number = {8},
  address = {Piscataway, NJ, USA},
  doi = {http://dx.doi.org/10.1109/32.57627},
  file = {Luqi - A Graph Model for Software Evolution (1990).pdf:artigos/Luqi
	- A Graph Model for Software Evolution (1990).pdf:PDF},
  issn = {0098-5589},
  publisher = {IEEE Press}
}

@ARTICLE{Ma2008,
  author = {Yutao Ma and Keqing He and Jing Liu},
  title = {Network Motifs in Object-Oriented Software Systems},
  journal = {CoRR},
  year = {2008},
  volume = {abs/0808.3292},
  abstract = {Nowadays, software has become a complex piece of work that may be
	beyond our control. Understanding how software evolves over time
	plays an important role in controlling software development processes.
	Recently, a few researchers found the quantitative evidence of structural
	duplication in software systems or web applications, which is similar
	to the evolutionary trend found in biological systems. To investigate
	the principles or rules of software evolution, we introduce the relevant
	theories and methods of complex networks into structural evolution
	and change of software systems. According to the results of our experiment
	on network motifs, we find that the stability of a motif shows positive
	correlation with its abundance and a motif with high Z score tends
	to have stable structure. These findings imply that the evolution
	of software systems is based on functional cloning as well as structural
	duplication and tends to be structurally stable. So, the work presented
	in this paper will be useful for the analysis of structural changes
	of software systems in reverse engineering.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://arxiv.org/abs/0808.3292},
  file = {Ma et al - Network Motifs in Object-Oriented Software Systems (2008).pdf:artigos/Ma
	et al - Network Motifs in Object-Oriented Software Systems (2008).pdf:PDF}
}

@CONFERENCE{Marchesi2004,
  author = {Michele Marchesi and Sandro Pinna and Nicola Serra and Stefano Tuveri},
  title = {Power Laws in Smalltalk},
  booktitle = {ESUG Conference},
  year = {2004},
  address = {Kothen, Germany},
  month = {September},
  file = {Power laws in Smalltalk (slides).pdf:artigos/Power laws in Smalltalk
	(slides).pdf:PDF},
  howpublished = {MARCHESI M., S. PINNA, N. SERRA, S. TUVERI. “Power Laws in Smalltalk”,
	ESUG CONFERENCE, 6-12 September 2004, Kothen, Germany.},
  owner = {rodrigo},
  timestamp = {2008.11.15}
}

@ARTICLE{Milo2002,
  author = {Milo, R. and Shen-Orr, S. and Itzkovitz, S. and Kashtan, N. and Chklovskii,
	D. and Alon, U. },
  title = {Network motifs: simple building blocks of complex networks.},
  journal = {Science},
  year = {2002},
  volume = {298},
  pages = {824--827},
  number = {5594},
  month = {October},
  abstract = {Complex networks are studied across many fields of science. To uncover
	their structural design principles, we defined "network motifs,"
	patterns of interconnections occurring in complex networks at numbers
	that are significantly higher than those in randomized networks.
	We found such motifs in networks from biochemistry, neurobiology,
	ecology, and engineering. The motifs shared by ecological food webs
	were distinct from the motifs shared by the genetic networks of Escherichia
	coli and Saccharomyces cerevisiae or from those found in the World
	Wide Web. Similar motifs were found in networks that perform information
	processing, even though they describe elements as different as biomolecules
	within a cell and synaptic connections between neurons in Caenorhabditis
	elegans. Motifs may thus define universal classes of networks. This
	approach may uncover the basic building blocks of most networks.},
  address = {Departments of Physics of Complex Systems and Molecular Cell Biology,
	Weizmann Institute of Science, Rehovot, Israel 76100.},
  citeulike-article-id = {101},
  doi = {10.1126/science.298.5594.824},
  issn = {1095-9203},
  keywords = {comp, comprehensive},
  posted-at = {2008-08-18 08:06:07},
  priority = {2},
  url = {http://dx.doi.org/10.1126/science.298.5594.824}
}

@ARTICLE{Moura2003,
  author = {Alessandro P.~S. de Moura and Ying-Cheng Lai and Adilson E. Motter},
  title = {Signatures of small-world and scale-free properties in large computer
	programs},
  journal = {Physical Review E},
  year = {2003},
  volume = {68},
  pages = {017102},
  file = {Moura et al - Signatures of small-world and scale-free properties
	in large computer programs (2003).pdf:artigos/Moura et al - Signatures
	of small-world and scale-free properties in large computer programs
	(2003).pdf:PDF},
  review = {= Revisão =
	
	
	Vértices: arquivos .h (cabeçalho de C e C++). Arestas: dois vértices
	estão conectados se eles são simultaneamente incluídos por um mesmo
	arquivo fonte (.c, .cpp, .cc...)
	
	
	Os autores analisam quatro sistemas: Linux kernel, XFree86, Mozilla
	e GIMP. Eles calculam distribuição de graus (não-orientado), caminho
	mínimo médio e coeficiente de clustering médio. Eles concluem que
	as redes são redes de mundo pequeno: alto clustering (>> Crand) e
	baixo diâmetro (~= Drand).
	
	
	Na verdade a rede seria bipartite entre arquivos fonte e arquivos
	de cabeçalho. O artigo estuda uma projeção dessa rede bipartite no
	conjunto de arquivos de cabeçalho. Um projeção no outro sentido fornece
	os mesmos resultados, segundo os autores.},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0306609}
}

@ARTICLE{Myers2003,
  author = {Christopher R Myers},
  title = {Software systems as complex networks: structure, function, and evolvability
	of software collaboration graphs.},
  journal = {Phys Rev E Stat Nonlin Soft Matter Phys},
  year = {2003},
  volume = {68},
  pages = {046116},
  number = {4 Pt 2},
  month = {Oct},
  abstract = {Software systems emerge from mere keystrokes to form intricate functional
	networks connecting many collaborating modules, objects, classes,
	methods, and subroutines. Building on recent advances in the study
	of complex networks, I have examined software collaboration graphs
	contained within several open-source software systems, and have found
	them to reveal scale-free, small-world networks similar to those
	identified in other technological, sociological, and biological systems.
	I present several measures of these network topologies, and discuss
	their relationship to software engineering practices. I also present
	a simple model of software system evolution based on refactoring
	processes which captures some of the salient features of the observed
	systems. Some implications of object-oriented design for questions
	about network robustness, evolvability, degeneracy, and organization
	are discussed in the wake of these findings.},
  institution = {Cornell Theory Center, Rhodes Hall, Cornell University, Ithaca, New
	York 14853, USA.},
  owner = {rodrigo},
  pmid = {14683011},
  review = {== Degree distributions ==
	
	
	Segue power law com expoentes gamma_in (para graus de entrada) e gamma_out
	(para graus de saída).
	
	
	Sistemas OO (arestas: colaboração entre classes = herança e agregação)
	
	gamma_out ~ 3
	
	gamma_in ~ 2
	
	
	Sistemas procedimentais (arestas: call graph)
	
	gamma_in = gamma_out = 2.5
	
	
	== Degree correlation ==
	
	
	Nós com alto grau de entrada têm baixo grau de saída e vice-versa.
	
	
	== Clustering coefficient ==
	
	
	C(k) ~ k^{-1} <-- indicador da natureza hierárquica do software
	
	
	C(k) é a média do coeficiente de clustering para os nós com grau k
	(considerando o grafo não orientado)
	
	
	== Misc ==
	
	
	O artigo introduz um modelo de evolução de software baseado em refactorings.},
  timestamp = {2008.11.15}
}

@MANUAL{Newman2005,
  title = {Power laws, Pareto distributions and Zipf's law},
  author = {M.~E.~J. Newman},
  year = {2005},
  journal = {Contemporary Physics},
  pages = {323},
  url = {doi:10.1080/00107510500052444},
  volume = {46}
}

@ARTICLE{Newman2004b,
  author = {M.~E.~J. Newman},
  title = {Fast algorithm for detecting community structure in networks},
  journal = {Physical Review E},
  year = {2004},
  volume = {69},
  pages = {066133},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0309508}
}

@ARTICLE{Newman2003,
  author = {M. E. J. Newman},
  title = {The structure and function of complex networks},
  journal = {SIAM Review},
  year = {2003},
  volume = {45},
  pages = {167--256}
}

@ARTICLE{Newman2004a,
  author = {M.~E.~J. Newman and M. Girvan},
  title = {Finding and evaluating community structure in networks},
  journal = {Physical Review E},
  year = {2004},
  volume = {69},
  pages = {026113},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0308217}
}

@ARTICLE{Park2007,
  author = {Park, Juyong and Barabasi, Albert-Laszlo},
  title = {Distribution of node characteristics in complex networks},
  journal = {Proceedings of the National Academy of Sciences},
  year = {2007},
  pages = {0705081104+},
  month = {November},
  note = {how the node properties correlate with the underlying network topology},
  abstract = {Our enhanced ability to map the structure of various complex networks
	is increasingly accompanied by the possibility of independently identifying
	the functional characteristics of each node. Although this led to
	the observation that nodes with similar characteristics have a tendency
	to link to each other, in general we lack the tools to quantify the
	interplay between node properties and the structure of the underlying
	network. Here we show that when nodes in a network belong to two
	distinct classes, two independent parameters are needed to capture
	the detailed interplay between the network structure and node properties.
	We find that the network structure significantly limits the values
	of these parameters, requiring a phase diagram to uniquely characterize
	the configurations available to the system. The phase diagram shows
	a remarkable independence from the network size, a finding that,
	together with a proposed heuristic algorithm, allows us to determine
	its shape even for large networks. To test the usefulness of the
	developed methods, we apply them to biological and socioeconomic
	systems, finding that protein functions and mobile phone usage occupy
	distinct regions of the phase diagram, indicating that the proposed
	parameters have a strong discriminating power. 10.1073/pnas.0705081104},
  citeulike-article-id = {1884115},
  doi = {http://dx.doi.org/10.1073/pnas.0705081104},
  file = {Park e Barabasi - Distribution of node characteristics in complex
	networks (2007).pdf:artigos/Park e Barabasi - Distribution of node
	characteristics in complex networks (2007).pdf:PDF},
  keywords = {network\_motifs, networks},
  posted-at = {2007-11-14 05:59:06},
  priority = {2},
  review = {Li superficialmente.
	
	
	O artigo apresenta uma análise sobre a relação entre propriedades
	de nós em uma rede e a topologia dessa rede. Ele introduz métricas
	como diadicidade (diadicity) e heterofilia.
	
	
	IDÉIA: estudar diadicidade e heterofilia de sistemas de software usando
	como propriedade o tipo de entidade: classe ou interface.},
  url = {http://dx.doi.org/10.1073/pnas.0705081104}
}

@INPROCEEDINGS{Pennock02,
  author = {David M. Pennock and Gary W. Flake and Steve Lawrence and Eric J.
	Glover and C. Lee Giles},
  title = {Winners don’t take all: Characterizing the competition for links
	on the web},
  booktitle = {Proceedings of the National Academy of Sciences},
  year = {2002},
  pages = {5207--5211},
  note = {generaliza modelo BA},
  abstract = {As a whole, the World Wide Web displays a striking "rich get richer"
	behavior, with a relatively small number of sites receiving a disproportionately
	large share of hyperlink references and traffic. However, hidden
	in this skewed global distribution, we discover a qualitatively different
	and considerably less biased link distribution among subcategories
	of pages---for example, among all university homepages or all newspaper
	homepages. While the connectivity distribution over the entire web
	is close to a pure power law, we find that the distribution within
	specific categories is typically unimodal on a log scale, with the
	location of the mode, and thus the extent of the "rich get richer"
	phenomenon, varying across different categories. Similar distributions
	occur in many other naturally-occurring networks, including research
	paper citations, movie actor collaborations, and US power grid connections.
	A simple generative model, incorporating a mixture of preferential
	and uniform attachment, quantifies the degree to which the rich nodes
	grow richer, and how new (and poorly-connected) nodes can compete.
	The model accurately accounts for the true connectivity distributions
	of category-specific web pages, the web as a whole, and other social
	networks.},
  review = {Site: http://modelingtheweb.com/
	
	
	= Resumo =
	
	
	NEC researchers discovered that the degree of "rich get richer" or
	"winners take all" behavior varies in different categories and may
	be significantly less than previously thought. A new model has been
	developed which can be used to predict and analyze competition and
	diversity in different communities on the web.
	
	
	O modelo mistura preferential attachment e uniform attachment. Modelo
	de grafo não-orientado, mas pode ser generalizado para grafo orientado.
	
	
	A distribuição de graus dentro de uma categoria tem um corpo log-normal
	e uma cauda lei de potência.
	
	
	Generalized BA model: every vertex has at least some baseline probability
	of gaining an edge.
	
	
	== Citações ==
	
	
	Generic and category-specific degree distributions.
	
	
	The probability that a randomly selected web page has k links is proportional
	to k^-gama for large k.
	
	
	A power law distribution has a heavy tail, which drops much more slowly
	than the tail of a Gaussian distribution.
	
	
	... a few pages have enormous number of links -- enough to skew the
	mean well above the median.
	
	
	It is an open question exactly how peaked distributions for subsets
	of the web like those in Figs. 1 and 2 sum together to produce nearly
	pure power law for the web as a whole. We conjecture that the vast
	majority of subsets (or subsets containing the vast majority of the
	pages) exhibit a nearly zero mode and dominate this sum, although
	more investigation is needed.
	
	
	Dorogovtsev et al and Levene et al independently propose similar generalizations
	of the BA model (the addition of a uniform component), motivating
	it in part as a natural way to parametrize the power-law exponent.
	
	
	Albert and Barabási (24) have proposed their own extension of their
	original model. Their augmented model involves a parametrized mixture
	of three processes: vertex additions, edge additions, and edge rewirings.
	
	
	== Crítica ==
	
	
	O autor escolheu os vértices a partir de listagens. Por exemplo, uma
	rede foi formada pelos sites de jornais americanos listados em www.usnewspaperlinks.com,
	que provavelmente não representa todos os sites de jornais americanos.
	Assim, parece haver uma tendência (bias).
	
	
	== TODO ==
	
	
	ver se a mesma distribuição é encontrada em módulos de programas,
	ou em pacotes de distribuições Linux de determinada seção (devel,
	graphics etc.)
	
	
	Reler e anotar seção Related Models.},
  timestamp = {2009.02.10},
  url = {http://modelingtheweb.com/pennock-pnas-2002-weblinks.pdf}
}

@ARTICLE{Potanin2005,
  author = {Alex Potanin and James Noble and Marcus Frean and Robert Biddle},
  title = {Scale-free geometry in OO programs},
  journal = {Commun. ACM},
  year = {2005},
  volume = {48},
  pages = {99--103},
  number = {5},
  abstract = {Though conventional OO design suggests programs should be built from
	many small objects, like Lego bricks, they are instead built from
	objects that are scale-free, like fractals, and unlike Lego bricks.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1060710.1060716},
  file = {Potanin et al - Scale-Free Geometry in OO Programs (2005) [communications].pdf:artigos/Potanin
	et al - Scale-Free Geometry in OO Programs (2005) [communications].pdf:PDF},
  issn = {0001-0782},
  publisher = {ACM},
  review = {= Revisão =
	
	
	O estudo analisa 8 sistemas em Java, C++, Self e Smalltalk.
	
	
	O estudo analisa 60 execuções de 35 sistemas escritos em Java, e também
	sistemas em C++, Self e Smalltalk.
	
	
	Aqui os autores estudam referências a objetos, em tempo de execução
	de programas Java. Eles concluem que os grafos de objetos são livres
	de escala (tanto para in- quanto para out-degree). Além disso, eles
	percebem que objetos com alto grau de saída possuem baixo grau de
	entrada e vice-versa.
	
	
	Frase de impacto: Objetos não são peças de Lego, pois não tem uma
	medida característica para in- ou out-degree.
	
	
	= Citações =
	
	
	Notably, no objects have both high in-degree and high out-degree;
	on the contrary, the objects with many incoming references have few
	outgoing references, and vice versa. This effect may be a consequence
	of widely shared data structures with many outgoing references (such
	as arrays) having a proxy object that hides the actual reference
	to the array the other objects that use it.
	
	
	unlike Lego bricks, objects within large programs have no characteristic
	scale.
	
	
	= Crítica =
	
	
	Não há um tratamento estatístico rigoroso.}
}

@ARTICLE{Ravasz2003,
  author = {Erzsebet Ravasz and Albert-Laszlo Barabasi},
  title = {Hierarchical Organization in Complex Networks},
  journal = {Physical Review E},
  year = {2003},
  volume = {67},
  pages = {026112},
  file = {Ravasz e Barabasi - Hierarchical organization in complex networks
	(2003).pdf:artigos/Ravasz e Barabasi - Hierarchical organization
	in complex networks (2003).pdf:PDF;Ravasz, Barabasi - Hierarchical
	organization in complex networks.pdf:misc-artigos/Ravasz, Barabasi
	- Hierarchical organization in complex networks.pdf:PDF},
  review = {O artigo apresenta um modelo determinístico de redes livres de escala
	hierárquicas e a partir dele deriva um modelo estocástico. A organização
	hierárquica é caracterizada pela distribuição do coeficiente de clustering,
	C(k), que obedece à lei C(k) ~ 1/k. Experimentos mostram que diversas
	redes possuem organização hierárquica -- rede de atores, rede de
	sinônimos, rede www, internet no domínio AS -- mas algumas outras
	-- internet no nível de roteador e rede elétrica -- não. Os autores
	atribuem a falta de organização hierárquica a restrições geográficas.
	Os autores apontam outros modelos que provavelmente obedecem à lei
	de escala C(k) ~ 1/k e concluem que o papel dos hubs em redes hierárquicas
	é unir os vários módulos coesos.
	
	
	== Citações
	
	
	the clustering coefficient of real networks is to a high degree independent
	of the number of nodes in the network (p. 1)
	
	
	modular: one can easily identify groups of nodes that are highly interconnected
	with each other, but have only a few or no links to nodes outside
	of the grop to which they belong to (p. 1)
	
	
	We argue that his scaling law quantifies the coexistence of a hierarchy
	of nodes with different degrees of clustering (p. 3)
	
	
	hierarchy is absent in networks with strong geographical constraints,
	as the limitation on the link length strongly constraints the network
	topology (p. 4)
	
	
	the fitness model [39, 40] displays a C(k) that appears to scale with
	k. (p. 5)
	
	
	there is evidence that the model of active nodes [41] obeys the scaling
	law (p. 5)
	
	
	the scaling of C(k) depends on the parameter p, which governs the
	rate at which new nodes connect to the neighbors of selected nodes.
	(p. 6)
	
	
	most networks have a modular topology, quantified by the high clustering
	coefficient they display. (p. 6)
	
	
	we should not think of modularity as the coexistence of relatively
	independent groups of nodes. (p. 6)
	
	
	the hubs play the important role of bridging the many small communities
	of clusters into a single, integrated network. (p. 6)},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0206130}
}

@ARTICLE{Ravasz2002,
  author = {Ravasz, E. and Somera, A. L. and Mongru, D. A. and Oltvai, Z. N.
	and Barab\'{a}si, A. L.},
  title = {Hierarchical organization of modularity in metabolic networks.},
  journal = {Science},
  year = {2002},
  volume = {297},
  pages = {1551--5},
  number = {5586},
  abstract = {Spatially or chemically isolated functional modules composed of several
	cellular components and carrying discrete functions are considered
	fundamental building blocks of cellular organization, but their presence
	in highly integrated biochemical networks lacks quantitative support.
	Here, we show that the metabolic networks of 43 distinct organisms
	are organized into many small, highly connected topologic modules
	that combine in a hierarchical manner into larger, less cohesive
	units, with their number and degree of clustering following a power
	law. Within Escherichia coli, the uncovered hierarchical modularity
	closely overlaps with known metabolic functions. The identified network
	architecture may be generic to system-level cellular organization.},
  citeulike-article-id = {2846539},
  file = {Ravasz et al - Hierarchical Organization of Modularity in Metabolic
	Networks (2002).pdf:artigos/Ravasz et al - Hierarchical Organization
	of Modularity in Metabolic Networks (2002).pdf:PDF},
  keywords = {file-import-08-05-30},
  posted-at = {2008-05-30 05:53:26},
  priority = {2}
}

@PHDTHESIS{Serra2005,
  author = {Nicola Serra},
  title = {Power Laws in Object Oriented System Architectures},
  school = {Università di Cagliari, Italy},
  year = {2005},
  owner = {rodrigo},
  timestamp = {2009.03.04}
}

@MASTERSTHESIS{Stopford2005,
  author = {Benjamin Stopford},
  title = {An Experimental Simulation of the Evolution of Software},
  school = {Univ. of London},
  year = {2005},
  month = {September},
  file = {Stopford - [Master Thesis] An Experimental Simulation of the Evolution
	of Software (2005).pdf:artigos/Stopford - [Master Thesis] An Experimental
	Simulation of the Evolution of Software (2005).pdf:PDF},
  owner = {rodrigo},
  timestamp = {2009.01.11}
}

@ARTICLE{Stopford2008,
  author = {Benjamin Stopford and Steve Counsell},
  title = {A framework for the simulation of structural software evolution},
  journal = {ACM Trans. Model. Comput. Simul.},
  year = {2008},
  volume = {18},
  pages = {1--36},
  number = {4},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1391978.1391983},
  file = {Stopford and Counsell - A Framework for the Simulation of Structural
	Software Evolution (2008).pdf:artigos/Stopford and Counsell - A Framework
	for the Simulation of Structural Software Evolution (2008).pdf:PDF},
  issn = {1049-3301},
  publisher = {ACM}
}

@ARTICLE{Stopford2006,
  author = {Benjamin Stopford and Steve Counsell},
  title = {Simulating the Structural Evolution of Software},
  year = {2006},
  volume = {3966/2006},
  pages = {294--301},
  book = {Software Process Change},
  doi = {10.1007/11754305_32},
  file = {Stopford and Counsell - Simulating the Structural Evolution of Software
	(2006).pdf:artigos/Stopford and Counsell - Simulating the Structural
	Evolution of Software (2006).pdf:PDF},
  issn = {1611-3349},
  owner = {rodrigo},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2009.01.11}
}

@MISC{Tamai2002,
  author = {Tetsuo Tamai and Takako Nakatani},
  title = {Analysis of software evolution processes using statistical distribution
	Models},
  year = {2002},
  file = {Tamai et al - Analysis of software evolution processes using statistical
	distribution models (2002).pdf:artigos/Tamai et al - Analysis of
	software evolution processes using statistical distribution models
	(2002).pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.31}
}

@BOOK{Tan2005,
  title = {Introduction to Data Mining},
  publisher = {Addison Wesley},
  year = {2005},
  author = {Tan, Pang-Ning and Steinbach, Michael and Kumar, Vipin },
  edition = {1},
  month = {May},
  abstract = {Introduction to Data Mining presents fundamental concepts and algorithms
	for those learning data mining for the first time. Each major topic
	is organized into two chapters, beginning with basic concepts that
	provide necessary background for understanding each data mining technique,
	followed by more advanced concepts and algorithms.},
  citeulike-article-id = {594811},
  howpublished = {Hardcover},
  isbn = {0321321367},
  keywords = {kdd},
  posted-at = {2007-09-05 16:37:59},
  priority = {2},
  url = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0321321367}
}

@ARTICLE{Valverde2002,
  author = {Valverde, S. and Ferrer Cancho, R. and Sol{\'e}, R.~V.},
  title = {Scale-free networks from optimal design},
  journal = {Europhysics Letters},
  year = {2002},
  volume = {60},
  pages = {512-517},
  month = nov,
  adsnote = {Provided by the SAO/NASA Astrophysics Data System},
  adsurl = {http://adsabs.harvard.edu/abs/2002EL.....60..512V},
  doi = {10.1209/epl/i2002-00248-2},
  eprint = {arXiv:cond-mat/0204344},
  file = {Valverde et al - Scale-free Networks from Optimal Design (2002).pdf:artigos/Valverde
	et al - Scale-free Networks from Optimal Design (2002).pdf:PDF},
  review = {= Revisão =
	
	
	Os autores argumentam que as características emergentes de grafos
	de software (livres de escala e mundo pequeno) são o resultado de
	um processo de otimização local, e não de preferential attachment.
	Esse processo de otimização não é bem explicado.
	
	
	== Citações ==
	
	
	Although the rules that define the strategies involved in software
	engineering should lead to a tree-like structure, the final net is
	scale-free, perhaps reflecting the presence of conflicting constraints
	unavoidable in a multidimensional optimization process. (p.1, abstract)
	
	
	cost minimization together with optimal communication among units
	
	
	Essentially, they deal with optimal communication among modules and
	low cost (in terms of wiring) together with the
	
	rule of avoiding hubs (classes with large number of dependencies,
	that is, large degree).
	
	
	Intuitively, a trade-off between the number of nodes and the number
	of links must be chosen.
	
	
	plot: l log(<k>) vs. N, onde l é a média dos caminhos mais curtos.}
}

@ARTICLE{Valverde2005,
  author = {Valverde, Sergi and Solé, Ricard V.},
  title = {Network motifs in computational graphs: A case study in software
	architecture},
  journal = {Physical Review E (Statistical, Nonlinear, and Soft Matter Physics)},
  year = {2005},
  volume = {72},
  number = {2},
  abstract = {Complex networks in both nature and technology have been shown to
	display characteristic, small subgraphs (so-called motifs) which
	appear to be related to their underlying functionality. All these
	networks share a common trait: they manipulate information at different
	scales in order to perform some kind of computation. Here we analyze
	a large set of software class diagrams and show that several highly
	frequent network motifs appear to be a consequence of network heterogeneity
	and size, thus suggesting a somewhat less relevant role of functionality.
	However, by using a simple model of network growth by duplication
	and rewiring, it is shown the rules of graph evolution seem to be
	largely responsible for the observed motif distribution.},
  citeulike-article-id = {2307657},
  comment = {8 pages},
  doi = {http://dx.doi.org/10.1103/PhysRevE.72.026107},
  keywords = {motif},
  posted-at = {2008-01-30 15:28:11},
  priority = {2},
  publisher = {APS},
  review = {Motifs (motivos) são subgrafos pequenos e característicos de um grafo.
	Este trabalho analisou 83 sistemas de software e encontrou diversos
	motivos frequentes comuns aos sistemas analisados e a redes de neurônios,
	circuitos eletrônicos e transcrição de genes, dentre os quais bi-fan,
	bi-parallel e feed forward loop. Ele também propôs um modelo de rede
	baseado em duplicação.
	
	
	Motivos podem estar associados a funcionalidades específicas, mas
	no caso de software, a formação dos motivos se deve a regras de evolução
	da rede. 
	
	
	Algumas conclusões do estudo:
	
	
	* A frequência de um motivo é proporcional ao tamanho da rede. (Fig.4,
	p. 5)
	
	* most common subgraphs are sparser than less common ones, which are
	more dense. 
	
	* Such a common point might be easily interpreted in functional terms:
	similar subgraphs are abundant because they are selected or chosen
	to perform a given function or task. As shown below, no evidence
	from statistical patterns supports such view.
	
	
	O artigo apresenta muita matemática (estatística) sobre motifs.
	
	
	Os autores propõem um modelo de rede baseado em duplicação:
	
	
	Primeiro é criado um grafo pequeno da seguinte forma: a cada passo
	é adicionado um nó com grau k_0 = 2, que se liga a vértices aleatoriamente.
	A seguir são aplicadas as seguintes regras:
	
	1) Duplicação: um vértice v, escolhido aleatoriamente, é clonado,
	e novo vértice w é ligado a todos os vértices aos quais v está ligado.
	
	2) Divergência: para cada par de arestas originais e redundantes,
	remova um deles com probabilidade delta.
	
	3) Cross linking: crie a ligação w -> v com probabilidade beta. Essa
	etapa é importante para a formação de 3-subgrafos.
	
	
	Experimentos reveleram que esse modelo é capaz de produzir os motivos
	frequentes.
	
	Esse modelo foi introduzido na referência [6].
	
	
	
	[6] R. V. Solé, R. Pastor-Satorras, E. D. Smith, and T. Kepler,
	
	Adv. Complex Syst. 5, 43 2002; A. Vazquez, A. Flammini,
	
	A. Maritan, and A. Vespignani, Complexus 1, 38 2003; R.
	
	Pastor-Satorras, E. D. Smith, and R. V. Solé, J. Theor. Biol.
	
	222, 199 2003; J. Kim, P. L. Krapivsky, B. Kahng, and S.
	
	Redner, Phys. Rev. E 66, 055101 2002; K.-I. Goh, B. Kahng,
	
	and D. Kim, e-print q-bio.MN/0312009, v2; W. Banzhaf and P.
	
	Dwigth Kuo, J. Biol. Phys. Chem. 4, 85 2004.},
  url = {http://dx.doi.org/10.1103/PhysRevE.72.026107}
}

@ARTICLE{Valverde2003,
  author = {Sergi Valverde and Ricard V. Solé},
  title = {Hierarchical Small Worlds in Software Architecture},
  year = {2003},
  number = {Directed Scale-Free Graphs},
  file = {Valverde et al - Hierarchical Small Worlds in Software Architecture
	(2003).pdf:artigos/Valverde et al - Hierarchical Small Worlds in
	Software Architecture (2003).pdf:PDF},
  review = {Alerta: este artigo tem muito blá-blá-blá. Pulando essa parte, a análise
	experimental é boa.
	
	
	Os autores analisam cerca de 30 sistemas escritos em C++. As arestas
	do grafo englobam agregação, herança e tipos de retorno. Eis os resultados
	experimentais:
	
	1) O número de arestas (L) cresce linearmente com o tamanho (número
	de vértices) do sistema (N): L ~ N^1.17
	
	2) O clustering coefficient está entre 0,084 e 0,413
	
	3) O diâmetro médio está entre 2,66 e 6,54
	
	4) Um valor típico de k médio (grau de entrada + grau de saída) é
	5 (tirado do jogo ProRally 2002)
	
	5) Considere a distribuição cumulativa dos graus como uma power-law
	com expoente a.
	
	 - Valores típicos de a para grau de entrada estão entre 0.94 e 1.55.
	
	 - Valores típicos de a para grau de saída estão entre 1.41 e 2.39.
	
	 - Valores típicos de a para entrada/saída estão entre 1.37 e 1.74.
	
	6) Seja T a quantidade de arestas no fecho transitivo do grafo. T
	~ N^1.46 (p. 8)
	
	
	"O modelo de Barabási-Albert não reproduz o alto clustering presente
	em muitos sistemas." (interessante, meus experimentos mostraram padrões
	razoáveis de clustering coefficient).
	
	
	Os autores analisam algumas métricas de evolução, mas não chegam a
	resultados conclusivos.
	
	
	"It has been noticed several times that in order to advance the current
	state of software engineering a scientific theory is required." --
	Lehman e Ramil: "An Approach to a Theory of Software Evolution" (2001)
	
	
	-- Rodrigo, 19/11/2008},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0307278}
}

@ARTICLE{Vazquez2003,
  author = {Vázquez, Alexei},
  title = {Growing network with local rules: Preferential attachment, clustering
	hierarchy, and degree correlations},
  journal = {Phys. Rev. E},
  year = {2003},
  volume = {67},
  pages = {056104},
  number = {5},
  month = {May},
  note = {duplication-divergence, connecting neighbors, random walk},
  doi = {10.1103/PhysRevE.67.056104},
  numpages = {15},
  owner = {rodrigo},
  publisher = {American Physical Society},
  timestamp = {2009.01.19}
}

@ARTICLE{Vazquez2003a,
  author = {A. Vázquez and A. Flammini and A. Maritan and A. Vespignani},
  title = {Modeling of protein interaction networks},
  journal = {Complexus},
  year = {2003},
  volume = {1},
  pages = {38},
  note = {duplication-divergence},
  file = {Vazquez et al - Modeling of protein interaction networks (2003).pdf:Vazquez
	et al - Modeling of protein interaction networks (2003).pdf:PDF},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0108043}
}

@ARTICLE{Watts1998,
  author = {Watts, D. J. and Strogatz, S. H. },
  title = {Collective dynamics of 'small-world' networks.},
  journal = {Nature},
  year = {1998},
  volume = {393},
  pages = {440--442},
  number = {6684},
  month = {June},
  abstract = {Networks of coupled dynamical systems have been used to model biological
	oscillators, Josephson junction arrays, excitable media, neural networks,
	spatial games, genetic control networks and many other self-organizing
	systems. Ordinarily, the connection topology is assumed to be either
	completely regular or completely random. But many biological, technological
	and social networks lie somewhere between these two extremes. Here
	we explore simple models of networks that can be tuned through this
	middle ground: regular networks 'rewired' to introduce increasing
	amounts of disorder. We find that these systems can be highly clustered,
	like regular lattices, yet have small characteristic path lengths,
	like random graphs. We call them 'small-world' networks, by analogy
	with the small-world phenomenon (popularly known as six degrees of
	separation. The neural network of the worm Caenorhabditis elegans,
	the power grid of the western United States, and the collaboration
	graph of film actors are shown to be small-world networks. Models
	of dynamical systems with small-world coupling display enhanced signal-propagation
	speed, computational power, and synchronizability. In particular,
	infectious diseases spread more easily in small-world networks than
	in regular lattices.},
  address = {Department of Theoretical and Applied Mechanics, Cornell University,
	Ithaca, New York 14853, USA. djw24@columbia.edu},
  citeulike-article-id = {99},
  doi = {10.1038/30918},
  issn = {0028-0836},
  keywords = {complex\_networks, complex\_systems, network, network\_generation\_model,
	small\_world},
  posted-at = {2007-10-10 03:41:03},
  priority = {5},
  url = {http://dx.doi.org/10.1038/30918}
}

@ARTICLE{Wen2007,
  author = {Lian Wen and Kirk, D. and Dromey, R.G.},
  title = {Software Systems as Complex Networks},
  journal = {Cognitive Informatics, 6th IEEE International Conference on},
  year = {2007},
  pages = {106-115},
  month = {Aug.},
  doi = {10.1109/COGINF.2007.4341879},
  file = {Wen et al - Software Systems as Complex Networks (2007).pdf:artigos/Wen
	et al - Software Systems as Complex Networks (2007).pdf:PDF;Myers
	- Software systems as complex networks, structure, function, and
	evolvability of software collaboration graphs (2003).pdf:artigos/Myers
	- Software systems as complex networks, structure, function, and
	evolvability of software collaboration graphs (2003).pdf:PDF},
  keywords = {Java, large-scale systems, software libraries, software maintenance,
	systems re-engineeringJava libraries, complex networks, component
	dependency network, scale-free network model, software maintenance,
	software reengineering, software systems}
}

@ARTICLE{Wheeldon2003,
  author = {Wheeldon, R. and Counsell, S.},
  title = {Power law distributions in class relationships},
  journal = {Source Code Analysis and Manipulation, 2003. Proceedings. Third IEEE
	International Workshop on},
  year = {2003},
  pages = { 45-54},
  month = {Sept.},
  abstract = {Power law distributions have been found in many natural and social
	phenomena, and more recently in the source code and run-time characteristics
	of Object-Oriented (OO) systems. A power law implies that small values
	are extremely common, whereas large values are extremely rare. We
	identify twelve new power laws relating to the static graph structures
	of Java programs. The graph structures analyzed represented different
	forms of OO coupling, namely, inheritance, aggregation, interface,
	parameter type and return type. Identification of these new laws
	provides the basis for predicting likely features of classes in future
	developments. The research ties together work in object-based coupling
	and World Wide Web structures.},
  issn = { },
  keywords = { Java, data flow graphs, inheritance, object-oriented programming,
	source coding Java program, World Wide Web structure, aggregation,
	inheritance, object-based coupling, object-oriented system, power
	law distribution, run-time characteristics, static graph structure}
}

@ARTICLE{Xu2006,
  author = {RenZuo Xu and XiaoDong Zhu and DaPeng Qi and Wei Huang and Wen Liu
	and Shuang Ming and AnCe Huang},
  title = {Investigation on Complex Networks in Software Engineering},
  journal = {Management of Innovation and Technology, 2006 IEEE International
	Conference on},
  year = {2006},
  volume = {1},
  pages = {532-534},
  month = {June },
  doi = {10.1109/ICMIT.2006.262238},
  file = {Xu et al - Investigation on Complex Networks in Software Engineering
	(2006).pdf:artigos/Xu et al - Investigation on Complex Networks in
	Software Engineering (2006).pdf:PDF;Investigation on Complex Networks
	in Software Engineering.txt:Para categorizar/Investigation on Complex
	Networks in Software Engineering.txt:Text},
  keywords = {configuration management, project management, software development
	managementcomplex network theory, finance management, manpower management,
	small world phenomenon, software development schedule management,
	software engineering, software project success rate, software version
	management}
}

@comment{jabref-meta: groupsversion:3;}

@comment{jabref-meta: groupstree:
0 AllEntriesGroup:;
1 ExplicitGroup:software as complex network\;0\;Baxter2006\;Chatzigeor
giou2006\;Concas2007\;Hyland-Wood2006\;Ichii2008\;Labelle2004\;Li2008\
;Louridas2008\;Ma2008\;Marchesi2004\;Moura2003\;Myers2003\;Potanin2005
\;Serra2005\;Valverde2002\;Valverde2003\;Valverde2005\;Wen2007\;Wheeld
on2003\;Xu2006\;;
1 ExplicitGroup:generative model\;0\;Aiello2000a\;Aiello2000b\;Bolloba
s2003\;Deo2005\;Dorogovtsev2002\;Eppstein2002\;Fu2006\;Han2006\;Kumar2
000\;Lancichinetti2008\;Pennock02\;Ravasz2003\;Valverde2005\;Vazquez20
03\;Vazquez2003a\;;
1 ExplicitGroup:hierarchy, modularity\;0\;Clauset2006\;Clauset2008\;Do
rogovtsev2002\;Han2006\;Ravasz2002\;Ravasz2003\;;
1 ExplicitGroup:software engineering\;0\;Challet2003\;Chatzigeorgiou20
06\;Drappa2000\;Herraiz2007\;Lopez2004\;Luqi1990\;Stopford2005\;Stopfo
rd2006\;Stopford2008\;Tamai2002\;;
1 ExplicitGroup:motifs\;0\;Ma2008\;Valverde2005\;;
1 ExplicitGroup:communities\;0\;Gulbahce2008\;Lancichinetti2008\;;
1 ExplicitGroup:distros Linux\;0\;;
1 ExplicitGroup:LIDO\;0\;Amaral00\;Andrade2008\;Baxter2006\;Bollobas20
03\;Concas2007\;Deo2005\;Fagiolo2006\;Han2006\;Herraiz2007\;Hyland-Woo
d2006\;Ichii2008\;Labelle2004\;Lancichinetti2008\;Li2008\;Linked\;Lour
idas2008\;Moura2003\;Myers2003\;Park2007\;Pennock02\;Potanin2005\;Rava
sz2003\;Valverde2002\;Valverde2003\;Valverde2005\;;
1 KeywordGroup:REVISADO\;0\;review\;a\;0\;0\;;
1 ExplicitGroup:benchmark for clustering\;0\;Lancichinetti2008\;;
}

% This file was created with JabRef 2.4.2.
% Encoding: Cp1252

@INPROCEEDINGS{Andreopoulos2005,
  author = {Andreopoulos, B. and An, Aijun and Tzerpos, V. and Wang, Xiaogang},
  title = {Multiple layer clustering of large software systems},
  booktitle = {Proc. th Working Conference on Reverse Engineering},
  year = {2005},
  pages = {10 pp.--},
  abstract = {Software clustering algorithms presented in the literature rarely
	incorporate in the clustering process dynamic information, such as
	the number of function invocations during runtime. Moreover, the
	structure of a software system is often multi-layered, while existing
	clustering algorithms often create flat system decompositions. This
	paper presents a software clustering algorithm called MULICsoft that
	incorporates in the clustering process both static and dynamic information.
	MULICsoft produces layered clusters with the core elements of each
	cluster assigned to the top layer. We present experimental results
	of applying MULICsoft to a large open-source system. Comparison with
	existing software clustering algorithms indicates that MULICsoft
	is able to produce decompositions that are close to those created
	by system experts.},
  doi = {10.1109/WCRE.2005.24},
  file = {Andreopoulos, Tzerpos et al - Multiple Layer Clustering of Large Software
	Systems (2005).pdf:papers/Andreopoulos, Tzerpos et al - Multiple
	Layer Clustering of Large Software Systems (2005).pdf:PDF},
  issn = {1095-1350},
  keywords = {public domain software, software engineering, MULICsoft, dynamic information
	clustering, flat system decompositions, function invocations, open-source
	system, software clustering, static information clustering},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Andritsos2005,
  author = {Andritsos, P. and Tzerpos, V.},
  title = {Information-theoretic software clustering},
  journal = {IEEE Transactions on Software Engineering},
  year = {2005},
  volume = {31},
  pages = {150--165},
  number = {2},
  note = {LIMBO},
  __markedentry = {[rodrigo]},
  abstract = {The majority of the algorithms in the software clustering literature
	utilize structural information to decompose large software systems.
	Approaches using other attributes, such as file names or ownership
	information, have also demonstrated merit. At the same time, existing
	algorithms commonly deem all attributes of the software artifacts
	being clustered as equally important, a rather simplistic assumption.
	Moreover, no method that can assess the usefulness of a particular
	attribute for clustering purposes has been presented in the literature.
	In this paper, we present an approach that applies information theoretic
	techniques in the context of software clustering. Our approach allows
	for weighting schemes that reflect the importance of various attributes
	to be applied. We introduce LIMBO, a scalable hierarchical clustering
	algorithm based on the minimization of information loss when clustering
	a software system. We also present a method that can assess the usefulness
	of any nonstructural attribute in a software clustering context.
	We applied LIMBO to three large software systems in a number of experiments.
	The results indicate that this approach produces clusterings that
	come close to decompositions prepared by system experts. Experimental
	results were also used to validate our usefulness assessment method.
	Finally, we experimented with well-established weighting schemes
	from information retrieval, Web search, and data clustering. We report
	results as to which weighting schemes show merit in the decomposition
	of software systems.},
  doi = {10.1109/TSE.2005.25},
  issn = {0098-5589},
  keywords = {information retrieval, pattern clustering, reverse engineering, software
	architecture, software maintenance, software metrics, systems re-engineering,
	Web search, data clustering, information retrieval, software clustering,
	software system, Index Terms- Reverse engineering, architecture reconstruction,
	clustering, information theory., reengineering},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Andritsos2003,
  author = {Andritsos, P. and Tzerpos, V. },
  title = {Software clustering based on information loss minimization},
  booktitle = {Proc. 10th Working Conference on Reverse Engineering WCRE 2003},
  year = {2003},
  pages = {334--344},
  issn = {1095-1350},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@ARTICLE{Anquetil1997,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  title = {File Clustering Using Naming Conventions for Legacy Systems},
  year = {1997},
  file = {File Clustering Using Naming Conventions for Legacy Systems.pdf:papers/File
	Clustering Using Naming Conventions for Legacy Systems.pdf:PDF;File
	Clustering Using Naming Conventions for Legacy Systems.pdf:papers/File
	Clustering Using Naming Conventions for Legacy Systems.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Anquetil2003,
  author = {Anquetil, N. and Lethbridge, T. C.},
  title = {Comparative study of clustering algorithms and abstract representations
	for software remodularisation},
  journal = {IEE Proceedings -Software},
  year = {2003},
  volume = {150},
  pages = {185--201},
  number = {3},
  abstract = {As valuable software systems become older, reverse engineering becomes
	increasingly important to companies that have to maintain the code.
	Clustering is a key activity in reverse engineering that is used
	to discover improved designs of systems or to extract significant
	concepts from code. Clustering is an old, highly sophisticated, activity
	which offers many methods to meet different needs. The various methods
	have been well documented in the past; however, conclusions from
	general clustering literature may not apply entirely to the reverse
	engineering domain. In the paper, the authors study three decisions
	that need to be made when clustering: the choice of (i) abstract
	descriptions of the entities to be clustered, (ii) metrics to compute
	coupling between the entities, and (iii) clustering algorithms. For
	each decision, our objective is to understand which choices are best
	when performing software remodularisation. The experiments were conducted
	on three public domain systems (gcc, Linux and Mosaic) and a real
	world legacy system (2 million LOC). Among other things, the authors
	confirm the importance of a proper description scheme for the entities
	being clustered, list a few effective coupling metrics and characterise
	the quality of different clustering algorithms. They also propose
	description schemes not directly based on the source code, and advocate
	better formal evaluation methods for the clustering results.},
  doi = {10.1049/ip-sen:20030581},
  issn = {1462-5970},
  keywords = {reverse engineering, software engineering, abstract descriptions,
	clustering, formal evaluation methods, public domain systems, real
	world legacy system, reverse engineering, software remodularisation,
	valuable software systems},
  owner = {roden},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Anquetil1999,
  author = {Anquetil, N. and Lethbridge, T. C.},
  title = {Experiments with clustering as a software remodularization method},
  booktitle = {Proc. Sixth Working Conference on Reverse Engineering},
  year = {1999},
  pages = {235--255},
  note = {Precision, Recall},
  abstract = {As valuable software systems get old, reverse engineering becomes
	more and more important to the companies that have to maintain the
	code. Clustering is a key activity in reverse engineering to discover
	a better design of the systems or to extract significant concepts
	from the code. Clustering is an old activity, highly sophisticated,
	offering many methods to answer different needs. Although these methods
	have been well documented in the past, these discussions may not
	apply entirely to the reverse engineering domain. We study some clustering
	algorithms and other parameters to establish whether and why they
	could be used for software remodularization. We study three aspects
	of the clustering activity: abstract descriptions chosen for the
	entities to cluster; metrics computing coupling between the entities;
	and clustering algorithms. The experiments were conducted on three
	public domain systems (gcc, Linux and Mosaic) and a real world legacy
	system (2 million LOC). Among other things, we confirm the importance
	of a proper description scheme of the entities being clustered, we
	list a few good coupling metrics to use and characterize the quality
	of different clustering algorithms. We also propose novel description
	schemes not directly based on the source code and we advocate better
	formal evaluation methods for the clustering results},
  doi = {10.1109/WCRE.1999.806964},
  file = {Experiments with Clustering as a Software Remodularization Method.pdf:papers/Experiments
	with Clustering as a Software Remodularization Method.pdf:PDF},
  keywords = {reverse engineering, software maintenance, software metrics, Linux,
	Mosaic, abstract descriptions, clustering activity, clustering algorithms,
	coupling metrics, description scheme, description schemes, formal
	evaluation methods, gcc, metrics, public domain systems, real world
	legacy system, reverse engineering domain, software remodularization,
	software remodularization method, source code, valuable software
	systems},
  owner = {roden},
  timestamp = {2008.10.10}
}

@MISC{Bowman1998,
  author = {Bowman and Holt},
  title = {Software Architecture Recovery Using Conway's Law},
  year = {1998},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@MISC{Bowman1999,
  author = {Bowman, I T},
  title = {Architecture Recovery for Object Oriented Systems},
  year = {1999},
  note = {Nao consegui achar o texto completo.},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@INPROCEEDINGS{Chikofsky2005,
  author = {Chikofsky, E. },
  title = {On the Meeting of Software Architecture and Reverse Engineering},
  booktitle = {Proc. 5th Working IEEE/IFIP Conference on Software Architecture WICSA
	2005},
  year = {2005},
  pages = {17--24},
  abstract = {This year, the 12th Working Conference on Reverse Engineering (WCRE)
	is meeting in conjunction with the 5th IEEE/IFIP Working Conference
	on Software Architecture (WICSA) in Mellon University. However, that
	linking phrase "in conjunction with" does not do justice to the vision,
	discussions, creativity, and effort that have brought us here.},
  doi = {10.1109/WICSA.2005.48},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@BOOK{Clements2002,
  title = {Documenting Software Architectures: Views and Beyond},
  publisher = {Pearson Education},
  year = {2002},
  author = {Clements, Paul and Garlan, David and Bass, Len and Stafford, Judith
	and Nord, Robert and Ivers, James and Little, Reed},
  isbn = {0201703726}
}

@MISC{Czibula2007,
  author = {Czibula and Serban},
  title = {Hierarchical Clustering for Software Systems Restructuring},
  year = {2007},
  file = {Czibula, Serban - Hierarchical Clustering for Software Systems Restructuring
	(2007).pdf:papers/Czibula, Serban - Hierarchical Clustering for Software
	Systems Restructuring (2007).pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Ding2001,
  author = {Ding, Lei and Medvidovic, N. },
  title = {Focus: a light-weight, incremental approach to software architecture
	recovery and evolution},
  booktitle = {Proc. Working IEEE/IFIP Conference on Software Architecture},
  year = {2001},
  pages = {191--200},
  note = {OO Recovery},
  abstract = {During the past decade (1991-2001), object-orientation (OO) has become
	the dominant software development methodology, accompanied by a number
	of modeling notations, programming languages, and development environments.
	OO applications of today are increasingly complex and user driven.
	They are also developed more rapidly and evolved more frequently
	than was the case with software systems of the past. All of these
	factors contribute to a plethora of potential problems when maintaining
	and evolving an OO application. These problems are caused by architectural
	erosion, where the initial architecture of an application is (arbitrarily)
	modified to the point where its key properties no longer hold. We
	propose an approach, called Focus, whose goal is to enable effective
	evolution of such an application with minimal effort, by recovering
	its architecture and using it as the basis of evolution. Focus allows
	engineers to direct their primary attention to the part of the system
	that is directly impacted by the desired change; subsequent changes
	will incrementally uncover additional parts of the system's architecture.
	We have applied Focus to four off-the-shelf applications to date.
	We discuss its key strengths and point out several open issues that
	will frame our future work},
  doi = {10.1109/WICSA.2001.948429},
  keywords = {graphical user interfaces, object-oriented programming, software architecture,
	software prototyping, system recovery, Focus, GUI, OO application
	evolution, OO architecture recovery, architectural erosion, light-weight
	incremental approach, modeling notations, object-orientation, off-the-shelf
	applications, software architecture evolution, software architecture
	recovery, software development methodology},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@INPROCEEDINGS{Doval1999,
  author = {Doval, D. and Mancoridis, S. and Mitchell, B. S.},
  title = {Automatic clustering of software systems using a genetic algorithm},
  booktitle = {Proc. Software Technology and Engineering Practice STEP '99},
  year = {1999},
  pages = {73--81},
  abstract = {Large software systems tend to have a rich and complex structure.
	Designers typically depict the structure of software systems as one
	or more directed graphs. For example, a directed graph can be used
	to describe the modules (or classes) of a system and their static
	interrelationships using nodes and directed edges, respectively.
	We call such graphs &ldquo;module dependency graphs&rdquo; (MDGs).
	MDGs can be large and complex graphs. One way of making them more
	accessible is to partition them, separating their nodes (i.e. modules)
	into clusters (i.e. subsystems). In this paper, we describe a technique
	for finding &ldquo;good&rdquo; MDG partitions. Good partitions feature
	relatively independent subsystems that contain modules which are
	highly interdependent. Our technique treats finding a good partition
	as an optimization problem, and uses a genetic algorithm (GA) to
	search the extraordinarily large solution space of all possible MDG
	partitions. The effectiveness of our technique is demonstrated by
	applying it to a medium-sized software system},
  doi = {10.1109/STEP.1999.798481},
  keywords = {directed graphs, genetic algorithms, reverse engineering, search problems,
	software engineering, subroutines, automatic clustering, directed
	edges, directed graphs, genetic algorithm, graph node clusters, graph
	partitioning, independent subsystems, interdependent modules, large
	software systems, medium-sized software system, module dependency
	graphs, module subsystems, optimization, reverse engineering, solution
	space searching, static interrelationships},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Duenas1998,
  author = {Duenas, J. C. and Lopes de Oliveira, W. and de la Puente, J. A.},
  title = {Architecture recovery for software evolution},
  booktitle = {Proc. Second Euromicro Conference on Software Maintenance and Reengineering},
  year = {1998},
  pages = {113--119},
  note = {Spring layout pode ser usado para clustering. (citado por Trifu2001)},
  abstract = {The maintenance is a costly activity in the life cycle of software-intensive
	systems, especially when they must as adapted to evolving requirements,
	which is more likely as the size of the system grows. Software architecture
	is a novel approach to the development of such systems, that guides
	the process focusing the architects' attention on the structure of
	the system being built, thus allowing a controlled evolution. This
	approach is applied for large systems or families of products with
	a long evolution path, and is usually performed once a successful
	system has been built, so in fact its application requires recovery
	techniques in order to obtain and incorporate as much information
	as possible. Furthermore, since these systems tend to be large, automatic
	aids must be used by engineers in the recovery tasks to do cost effective
	work. The article describes the experience of architectural recovery
	of a large telecommunication system, presents the characteristics
	of the architectural recovery process applied, reviews some of the
	available recovery techniques and organises their application for
	software architecture recovery},
  doi = {10.1109/CSMR.1998.665766},
  keywords = {automatic programming, software maintenance, system recovery, systems
	analysis, telecommunication computing, architectural recovery, architectural
	recovery process, automatic aids, cost effective work, evolution
	path, evolving requirements, large systems, large telecommunication
	system, recovery tasks, recovery techniques, software architecture,
	software architecture recovery, software evolution, software maintenance,
	software-intensive systems},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@MISC{Eixelsberger,
  author = {Eixelsberger, Klosch},
  title = {A Framework for Software Architecture Recovery},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@PHDTHESIS{Hatch2004,
  author = {Hatch},
  title = {Software Architecture Visualisation},
  school = {Univ. of Durham},
  year = {2004},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Huynh2008,
  author = {Sunny Huynh and Yuanfang Cai and Yuanyuan Song and Kevin Sullivan},
  title = {Automatic modularity conformance checking},
  booktitle = {ICSE '08: Proceedings of the 30th international conference on Software
	engineering},
  year = {2008},
  pages = {411--420},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {According to Parnas's information hiding principle and Baldwin and
	Clark's design rule theory, the key step to decomposing a system
	into modules is to determine the design rules (or in Parnas's terms,
	interfaces) that decouple otherwise coupled design decisions and
	to hide decisions that are likely to change in independent modules.
	Given a modular design, it is often difficult to determine whether
	and how its implementation realizes the designed modularity. Manually
	comparing code with abstract design is tedious and error-prone. We
	present an automated approach to check the conformance of implemented
	modularity to designed modularity, using esign structure matricesas
	a uniform representation for both. Our experiments suggest that our
	approach has the potential to manifest the decoupling effects of
	esign rulesin code, and to detect modularity deviation caused by
	implementation faults. We also show that design and implementation
	models together provide a comprehensive view of modular structure
	that makes certain implicit dependencies within code explicit.},
  doi = {http://doi.acm.org/10.1145/1368088.1368144},
  file = {Cai et al - Automatic Modularity Conformance Checking.pdf:papers/Cai
	et al - Automatic Modularity Conformance Checking.pdf:PDF},
  isbn = {978-1-60558-079-1},
  location = {Leipzig, Germany},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Koschke2000a,
  author = {Koschke},
  title = {Atomic Architectural Component Recovery for Program Understanding
	and Evolution},
  school = {Univ. Stuttgart},
  year = {2000},
  file = {Koschke - [Thesis] Atomic Architectural Component Recovery for Program
	Understanding and Evolution.pdf:papers/Koschke - [Thesis] Atomic
	Architectural Component Recovery for Program Understanding and Evolution.pdf:PDF;Koschke
	- [Thesis] Atomic Architectural Component Recovery for Program Understanding
	and Evolution.pdf:papers/Koschke - [Thesis] Atomic Architectural
	Component Recovery for Program Understanding and Evolution.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Koschke2000,
  author = {Koschke, R. and Eisenbarth, T.},
  title = {A framework for experimental evaluation of clustering techniques},
  booktitle = {Proc. 8th International Workshop on Program Comprehension IWPC 2000},
  year = {2000},
  pages = {201--210},
  note = {Kosche-Eisenbarth (KE) measure},
  __markedentry = {[rodrigo]},
  abstract = {Experimental evaluation of clustering techniques for component recovery
	is necessary in order to analyze their strengths and weaknesses in
	comparison to other techniques. For comparable evaluations of automatic
	clustering techniques, a common reference corpus of freely available
	systems is needed for which the actual components are known. The
	reference corpus is used to measure recall and precision of automatic
	techniques. For this measurement, a standard scheme for comparing
	the components recovered by a clustering technique to components
	in the reference corpus is required. This paper describes both the
	process of setting up reference corpora and ways of measuring recall
	and precision of automatic clustering techniques. For methods with
	human intervention, controlled experiments should be conducted. This
	paper additionally proposes a controlled experiment as a standard
	for evaluating manual and semi-automatic component recovery methods
	that can be conducted cost-effectively},
  doi = {10.1109/WPC.2000.852494},
  file = {Koschke, Eisenbarth - [KE] A framework for experimental evaluation
	of clustering techniques.pdf:papers/Koschke, Eisenbarth - [KE] A
	framework for experimental evaluation of clustering techniques.pdf:PDF;Koschke,
	Eisenbarth - [KE] A framework for experimental evaluation of clustering
	techniques.pdf:papers/Koschke, Eisenbarth - [KE] A framework for
	experimental evaluation of clustering techniques.pdf:PDF},
  keywords = {reverse engineering, software reusability, clustering techniques,
	common reference corpus, cost-effective, experimental evaluation,
	program component recovery, program understanding},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Krikhaar1999,
  author = {Krikhaar},
  title = {Software Architecture Reconstruction},
  school = {Univ. of Amsterdam},
  year = {1999},
  note = {SARTool. Viewpoints, logic.},
  file = {Jha et al - A Comparison of Four Software Architecture Reconstruction
	Toolkits.pdf:papers/Jha et al - A Comparison of Four Software Architecture
	Reconstruction Toolkits.pdf:PDF;Pollet, Ducasse et al - Towards A
	Process-Oriented Software Architecture Reconstruction Taxonomy.pdf:papers/Pollet,
	Ducasse et al - Towards A Process-Oriented Software Architecture
	Reconstruction Taxonomy.pdf:PDF;Jha et al - A Comparison of Four
	Software Architecture Reconstruction Toolkits.pdf:papers/Jha et al
	- A Comparison of Four Software Architecture Reconstruction Toolkits.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Kuhn2005,
  author = {Kuhn, A. and Ducasse, S. and Girba, T.},
  title = {Enriching reverse engineering with semantic clustering},
  booktitle = {Proc. th Working Conference on Reverse Engineering},
  year = {2005},
  pages = {10 pp.--},
  abstract = {Understanding a software system by just analyzing the structure of
	the system reveals only half of the picture, since the structure
	tells us only how the code is working but not what the code is about.
	What the code is about can be found in the semantics of the source
	code: names of identifiers, comments etc. In this paper, we analyze
	how these terms are spread over the source artifacts using latent
	semantic indexing, an information retrieval technique. We use the
	assumption that parts of the system that use similar terms are related.
	We cluster artifacts that use similar terms, and we reveal the most
	relevant terms for the computed clusters. Our approach works at the
	level of the source code which makes it language independent. Nevertheless,
	we correlated the semantics with structural information and we applied
	it at different levels of abstraction (e.g. classes, methods). We
	applied our approach on three large case studies and we report the
	results we obtained.},
  doi = {10.1109/WCRE.2005.16},
  file = {Kuhn, Ducasse, Girba - Enriching reverse engineering with semantic
	clustering.pdf:papers/Kuhn, Ducasse, Girba - Enriching reverse engineering
	with semantic clustering.pdf:PDF;Kuhn, Ducasse, Girba - Enriching
	reverse engineering with semantic clustering.pdf:papers/Kuhn, Ducasse,
	Girba - Enriching reverse engineering with semantic clustering.pdf:PDF},
  issn = {1095-1350},
  keywords = {formal specification, indexing, information retrieval, program diagnostics,
	programming language semantics, reverse engineering, structured programming,
	artifacts clustering, information retrieval, latent semantic indexing,
	reverse engineering, semantic clustering, software system, source
	code semantic, system structure, clustering, concept location, reverse
	engineering, semantic analysis},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Lakhotia1995,
  author = {Lakhotia, A. and Gravley, J. M. },
  title = {Toward experimental evaluation of subsystem classification recovery
	techniques},
  booktitle = {Proc. 2nd Working Conference on Reverse Engineering},
  year = {1995},
  pages = {262--269},
  note = {Measure of Congruence},
  abstract = {Several reverse engineering techniques classify software system components
	into subsystems. These techniques are designed to discover such classifications
	when the classifications are unknown. The techniques are rested and
	evaluated, however, by matching the classifications they recover
	against expected classifications. Several such techniques may be
	compared by experimentally evaluating their performance on the same
	set of software systems. Two things are needed to ensure experiment
	repeatability: a set of &ldquo;real-world&rdquo; software systems
	whose expected subsystem classifications are known; and an objective
	criterion to quantitatively determine the similarity of subsystem
	classifications. This paper contributes to both needs by identifying
	a set of widely used and easily accessible software systems whose
	modular decomposition either is documented or can be easily inferred
	from their design philosophy, and by presenting a measure to quantitatively
	determine the congruence between hierarchical subsystem classifications},
  doi = {10.1109/WCRE.1995.514714},
  file = {Lakhotia, Gravley - [CongruenceMeasure] Toward Experimental Evaluation
	of Subsystem Classification Recovery Techniques.pdf:papers/Lakhotia,
	Gravley - [CongruenceMeasure] Toward Experimental Evaluation of Subsystem
	Classification Recovery Techniques.pdf:PDF},
  keywords = {reverse engineering, software performance evaluation, system documentation,
	design philosophy, experiment repeatability, hierarchical subsystem
	classifications, modular decomposition, performance evaluation, reverse
	engineering, subsystem classification recovery, subsystem classifications},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Landi1992,
  author = {William Landi},
  title = {Undecidability of Static Analysis},
  journal = {ACM Letters on Programming Languages and Systems},
  year = {1992},
  volume = {1},
  pages = {323--337}
}

@INPROCEEDINGS{Li2005,
  author = {Li, Qingshan},
  title = {Dynamic Model Design Recovery and Architecture Abstraction of Object
	Oriented Software},
  booktitle = {Proc. Ninth European Conference on Software Maintenance and Reengineering
	CSMR 2005},
  year = {2005},
  pages = {284--287},
  abstract = {The paper gives an overview of a Ph.D. thesis and describes the main
	contents of the thesis. The thesis makes research on reverse engineering
	of object-oriented software at source codes level. According to the
	dynamic property of object-oriented software system, a group of models,
	mechanisms and algorithms that can be used to extract dynamic information
	and abstract high-level models of such systems are provided in the
	thesis. A group of systematic experiments are also conducted in the
	thesis so as to verify the correctness, validity and other related
	performance of these dynamic model design recovery and architecture
	abstraction algorithms.},
  doi = {10.1109/CSMR.2005.26},
  issn = {1534-5351},
  keywords = {data structures, formal verification, object-oriented programming,
	reverse engineering, software architecture, architecture abstraction,
	design recovery, dynamic information, dynamic model, object oriented
	software, reverse engineering, Architecture Abstraction, Design Recovery,
	Object Orientation, Program Comprehension, Reverse Engineering},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@ARTICLE{Lindvall2008,
  author = {Lindvall, M. and Muthig, D. },
  title = {Bridging the Software Architecture Gap},
  journal = {Computer},
  year = {2008},
  volume = {41},
  pages = {98--101},
  number = {6},
  abstract = {There's a growing gap between the state of the art and the state of
	the practice in software architecture. The state of the art revolves
	around advanced architecture description and modeling languages,
	while in practice, the software architect - if there is one - has
	neither the power nor the tools to create a sound software architecture
	that is truly useful throughout the entire software life cycle. The
	SAVE tool helps developers align a system with the planned architecture.},
  doi = {10.1109/MC.2008.176},
  file = {Bridging the Software Architecture Gap.pdf:papers/Bridging the Software
	Architecture Gap.pdf:PDF;Bridging the Software Architecture Gap.pdf:papers/Bridging
	the Software Architecture Gap.pdf:PDF},
  issn = {0018-9162},
  keywords = {formal specification, software architecture, software prototyping,
	software tools, specification languages, SAVE tool, architecture
	description, modeling language, software architecture gap, software
	life cycle, software artchitecture, software development, visualization
	tools},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Mancoridis1996,
  author = {Mancoridis, S. and Holt, R. C.},
  title = {Recovering the structure of software systems using tube graph interconnection
	clustering},
  booktitle = {Proc. International Conference on Software Maintenance 1996},
  year = {1996},
  pages = {23--32},
  note = {Edge clustering},
  abstract = {An important product of the software design phase is the specification
	of the software structure at various levels of detail. Without reliable
	design documentation, significant software systems become less accessible
	to software engineers because structural information is buried in
	the intricate implementation source code. Reverse engineering techniques
	aim at recovering the structure of software systems, from the source
	code and mental models of developers, in order to make these systems
	more understandable to those maintaining them. Many reverse engineering
	techniques rely on creating a decomposition hierarchy by recursively
	clustering related software components (e.g., variables, procedures,
	classes, modules) into composite components (e.g., subsystems). Component
	clustering is necessary for managing complexity, and therefore is
	an important step in the reverse engineering process. We argue that
	the clustering of interconnections is also necessary during reverse
	engineering, We propose an approach, based on a formalism called
	tube graphs, to specifying system structure that considers both composite
	software components and composite interconnections between these
	components. We present efficient algorithms for software interconnection
	clustering, which nicely complement existing software component clustering
	algorithms},
  doi = {10.1109/ICSM.1996.564985},
  keywords = {formal specification, graph theory, reverse engineering, software
	maintenance, software reliability, component clustering, composite
	interconnections, composite software components, decomposition hierarchy,
	implementation source code, mental models, recursive clustering,
	related software components, reliable design documentation, reverse
	engineering techniques, software design phase, software engineers,
	software interconnection clustering, software structure specification,
	software systems, source code, structural information, structure
	recovery, system structure specification, tube graph interconnection
	clustering},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Mancoridis1998,
  author = {Mancoridis, S. and Mitchell, B. S. and Rorres, C. and Chen, Y. and
	Gansner, E. R.},
  title = {Using automatic clustering to produce high-level system organizations
	of source code},
  booktitle = {Proc. th International Workshop on Program Comprehension IWPC '98},
  year = {1998},
  pages = {45--52},
  note = {Bunch},
  __markedentry = {[rodrigo]},
  abstract = {We describe a collection of algorithms that we developed and implemented
	to facilitate the automatic recovery of the modular structure of
	a software system from its source code. We treat automatic modularization
	as an optimization problem. Our algorithms make use of traditional
	hill-climbing and genetic algorithms},
  doi = {10.1109/WPC.1998.693283},
  file = {Mancoridis, Mitchell et al - Using Automatic Clustering to Produce
	High-Level System Organizations of Source Code.pdf:papers/Mancoridis,
	Mitchell et al - Using Automatic Clustering to Produce High-Level
	System Organizations of Source Code.pdf:PDF},
  issn = {1092-8138},
  keywords = {genetic algorithms, graph theory, reverse engineering, software engineering,
	automatic clustering, automatic modularization, genetic algorithms,
	graph theory, high-level system organizations, hill-climbing algorithms,
	optimization problem, reverse engineering, software structure recovery,
	source code},
  owner = {roden},
  timestamp = {2008.10.10}
}

@ARTICLE{Maqbool2007,
  author = {Maqbool, O. and Babri, H. A.},
  title = {Hierarchical Clustering for Software Architecture Recovery},
  journal = IEEE_J_SE,
  year = {2007},
  volume = {33},
  pages = {759--780},
  number = {11},
  abstract = {Gaining an architectural level understanding of a software system
	is important for many reasons. When the description of a system's
	architecture does not exist, attempts must be made to recover it.
	In recent years, researchers have explored the use of clustering
	for recovering a software system's architecture, given only its source
	code. The main contributions of this paper are given as follows.
	First, we review hierarchical clustering research in the context
	of software architecture recovery and modularization. Second, to
	employ clustering meaningfully, it is necessary to understand the
	peculiarities of the software domain, as well as the behavior of
	clustering measures and algorithms in this domain. To this end, we
	provide a detailed analysis of the behavior of various similarity
	and distance measures that may be employed for software clustering.
	Third, we analyze the clustering process of various well-known clustering
	algorithms by using multiple criteria, and we show how arbitrary
	decisions taken by these algorithms during clustering affect the
	quality of their results. Finally, we present an analysis of two
	recently proposed clustering algorithms, revealing close similarities
	in their apparently different clustering approaches. Experiments
	on four legacy software systems provide insight into the behavior
	of well-known clustering algorithms and their characteristics in
	the software domain.},
  doi = {10.1109/TSE.2007.70732},
  file = {Maqbool, Babri - Hierarchical Clustering for Software Architecture
	Recovery (2007).pdf:papers/Maqbool, Babri - Hierarchical Clustering
	for Software Architecture Recovery (2007).pdf:PDF;Maqbool, Babri
	- Hierarchical Clustering for Software Architecture Recovery (2007).pdf:papers/Maqbool,
	Babri - Hierarchical Clustering for Software Architecture Recovery
	(2007).pdf:PDF},
  issn = {0098-5589},
  keywords = {software architecture, arbitrary decisions, architectural level understanding,
	clustering algorithms, hierarchical clustering research, software
	architecture recovery, software domain, software modularization,
	Restructuring, Software Engineering, and reengineering, arbitrary
	decisions, architecture recovery, hierarchical clustering, reverse
	engineering},
  owner = {roden},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Maqbool2005,
  author = {Maqbool, O. and Babri, H. A. },
  title = {Interpreting clustering results through cluster labeling},
  booktitle = {Proc. IEEE Symposium on Emerging Technologies},
  year = {2005},
  pages = {429--434},
  abstract = {Software architecture refers to the overall structure of a software
	system, and is defined by the components (sub-systems) within a software
	system and their interactions with one another. Quite often, there
	is little documentation describing a software system's architecture,
	especially in the case of legacy software systems. Thus techniques
	must be employed for recovering the architecture from the software's
	source code. Given the size and complexity of legacy systems, researchers
	have started exploring the use of automated techniques for architecture
	recovery. A technique that has shown promising results is clustering.
	Clusters that are obtained as a result of the clustering process
	represent sub-systems within a software system, but are nor easy
	to interpret until they are given appropriate names. In this paper,
	we present a cluster labeling scheme based on identifiers. As the
	clustering process proceeds, keywords are ranked using the inverse
	document frequency ranking scheme. Results of experiments conducted
	on a test system demonstrate that our labeling approach is effective.
	We also compare the clustering results of the complete algorithm
	and the weighted combined algorithm based on labels of the clusters
	produced by them during clustering.},
  doi = {10.1109/ICET.2005.1558920},
  file = {Maqbool, Babri - Interpreting Clustering Results through Cluster Labeling
	(2005).pdf:papers/Maqbool, Babri - Interpreting Clustering Results
	through Cluster Labeling (2005).pdf:PDF},
  keywords = {software architecture, software maintenance, system documentation,
	architecture recovery, cluster labeling, clustering process, documentation,
	identifiers, inverse document frequency ranking scheme, software
	architecture, source code, system, weighted combined algorithm},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Mendonca1999,
  author = {Mendona, N},
  title = {Software Architecture Recovery for Distributed Systems},
  school = {Univ. of London},
  year = {1999},
  owner = {rodrigo},
  timestamp = {2008.10.20}
}

@PHDTHESIS{Mitchell2002,
  author = {Mitchell, B. S.},
  title = {A Heuristic Search Approach to Solving the Software Clustering Problem},
  school = {Drexel University},
  year = {2002},
  note = {EdgeSim, MeCl},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Mitchell2001,
  author = {Mitchell, B. S. and Mancoridis, S.},
  title = {Comparing the decompositions produced by software clustering algorithms
	using similarity measurements},
  booktitle = {Proc. IEEE International Conference on Software Maintenance},
  year = {2001},
  pages = {744--753},
  note = {EdgeSim and MeCl},
  abstract = {Decomposing source code components and relations into subsystem clusters
	is an active area of research. Numerous clustering approaches have
	been proposed in the reverse engineering literature, each one using
	a different algorithm to identify subsystems. Since different clustering
	techniques may not produce identical results when applied to the
	same system, mechanisms that can measure the extent of these differences
	are needed. Some work to measure the similarity between decompositions
	has been done, but this work considers the assignment of source code
	components to clusters as the only criterion for similarity. We argue
	that better similarity measurements can be designed if the relations
	between the components are considered. The authors propose two similarity
	measurements that overcome certain problems in existing measurements.
	We also provide some suggestions on how to identify and deal with
	source code components that tend to contribute to poor similarity
	results. We conclude by presenting experimental results, and by highlighting
	some of the benefits of our similarity measurements},
  doi = {10.1109/ICSM.2001.972795},
  file = {Comparing the decompositions produced by software clustering algorithms
	using similarity measurements.pdf:papers/Comparing the decompositions
	produced by software clustering algorithms using similarity measurements.pdf:PDF;Comparing
	the decompositions produced by software clustering algorithms using
	similarity measurements.pdf:papers/Comparing the decompositions produced
	by software clustering algorithms using similarity measurements.pdf:PDF},
  keywords = {reverse engineering, software maintenance, software metrics, systems
	re-engineering, clustering approaches, clustering techniques, reverse
	engineering, similarity measurements, similarity results, software
	clustering algorithms, source code component decomposition, source
	code components, subsystem clusters},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@ARTICLE{Parnas1972,
  author = {Parnas,, D. L.},
  title = {On the criteria to be used in decomposing systems into modules},
  journal = {Commun. ACM},
  year = {1972},
  volume = {15},
  pages = {1053--1058},
  number = {12},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/361598.361623},
  issn = {0001-0782},
  publisher = {ACM}
}

@INPROCEEDINGS{Pollet2007,
  author = {Pollet, Damien and Ducasse, Stephane and Poyet, Loic and Alloui,
	Ilham and Cimpan, Sorana and Verjus, Herve},
  title = {Towards A Process-Oriented Software Architecture Reconstruction Taxonomy},
  booktitle = {Proc. 11th European Conference on Software Maintenance and Reengineering
	CSMR '07},
  year = {2007},
  pages = {137--148},
  abstract = {To maintain and understand large applications, it is crucial to know
	their architecture. The first problem is that unlike classes and
	packages, architecture is not explicitly represented in the code.
	The second problem is that successful applications evolve over time,
	so their architecture inevitably drifts. Reconstructing the architecture
	and checking whether it is still valid is therefore an important
	aid. While there is a plethora of approaches and techniques supporting
	architecture reconstruction, there is no comprehensive state of the
	art and it is often difficult to compare the approaches. This article
	presents a state of the art on software architecture reconstruction
	approaches},
  doi = {10.1109/CSMR.2007.50},
  file = {Pollet, Ducasse et al - Towards A Process-Oriented Software Architecture
	Reconstruction Taxonomy.pdf:papers/Pollet, Ducasse et al - Towards
	A Process-Oriented Software Architecture Reconstruction Taxonomy.pdf:PDF;Pollet,
	Ducasse et al - Towards A Process-Oriented Software Architecture
	Reconstruction Taxonomy.pdf:papers/Pollet, Ducasse et al - Towards
	A Process-Oriented Software Architecture Reconstruction Taxonomy.pdf:PDF},
  issn = {1534-5351},
  keywords = {software architecture, software architecture reconstruction, software
	development, taxonomy},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@PHDTHESIS{Riva2004,
  author = {Riva},
  title = {View-based Software Architecture Reconstruction},
  school = {Univ. of Vienna},
  year = {2004},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@PHDTHESIS{Sartipi2003a,
  author = {Sartipi},
  title = {Software Architecture Recovery based on Pattern Matching},
  school = {Univ. of Waterloo},
  year = {2003},
  note = {Revealer, bottom-up},
  file = {Sartipi - Software Architecture Recovery based on Pattern Matching
	(2003).pdf:papers/Sartipi - Software Architecture Recovery based
	on Pattern Matching (2003).pdf:PDF;Sartipi - [Thesis] Software Architecture
	Recovery based on Pattern Matching.pdf:papers/Sartipi - [Thesis]
	Software Architecture Recovery based on Pattern Matching.pdf:PDF;Sartipi
	- [Thesis] Software Architecture Recovery based on Pattern Matching.pdf:papers/Sartipi
	- [Thesis] Software Architecture Recovery based on Pattern Matching.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@ARTICLE{Sartipi2003,
  author = {Sartipi, K. and Kontogiannis, K.},
  title = {A User-assisted Approach to Component Clustering},
  journal = {J. Software Maintenance and Evolution: Research and Practice},
  year = {2003},
  volume = {15},
  pages = {265--295},
  number = {4},
  month = {July-Aug},
  abstract = {In this paper, we present a user assisted clustering technique for
	software architecture recovery based on a proximity measure that
	we call component association. The component association measure
	is computed on the shared properties among groups of highly related
	system entities. In this approach, the software system is modeled
	as an attributed relation graph with the software constructs (entities)
	represented as nodes and data/control dependencies represented as
	edges. The application of data mining techniques on the system graph
	allows to generate a component graph where the edges are labeled
	by the association strength values among the components. An interactive
	partitioning technique and environment is used to partition a system
	into cohesive subsystems where the graph visualization aids and cluster
	quality evaluation metrics are applied to assess and fine tune the
	partition by the user.},
  file = {Sartipi, Kontogiannis - A User-assisted Approach to Component Clustering.pdf:papers/Sartipi,
	Kontogiannis - A User-assisted Approach to Component Clustering.pdf:PDF;Sartipi,
	Kontogiannis - A User-assisted Approach to Component Clustering.pdf:papers/Sartipi,
	Kontogiannis - A User-assisted Approach to Component Clustering.pdf:PDF},
  keywords = {partitioning, association, data mining, architecture recovery, similarity,
	graph},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Shtern2007,
  author = {Shtern, Mark and Tzerpos, Vassilios},
  title = {Lossless Comparison of Nested Software Decompositions},
  booktitle = {Proc. 14th Working Conference on Reverse Engineering WCRE 2007},
  year = {2007},
  pages = {249--258},
  note = {UpMoJo},
  abstract = {Reverse engineering legacy software systems often involves the employment
	of clustering algorithms that automatically decompose a software
	system into subsys- tems. The decompositions created by existing
	software clustering algorithms are often nested, i.e. subsystems
	may contain other finer-grained subsystems as well as system resources,
	such as source files. It is rather sur- prising then, that almost
	all existing methods for de- composition comparison assume flat decompositions,
	i.e. subsystems only contain system resources. In this paper, we
	introduce UpMoJo, a novel com- parison method for software decompositions
	that can be applied to both nested and flat decompositions. The ben-
	efits of utilizing this method are presented in both ana- lytical
	and experimental fashion. We also compare Up- MoJo to the END framework,
	the only other existing method for nested decomposition comparison.},
  doi = {10.1109/WCRE.2007.32},
  file = {Shtern, Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:papers/Shtern,
	Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:PDF;Shtern,
	Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:papers/Shtern,
	Tzerpos - Lossless Comparison of Nested Software Decompositions.pdf:PDF},
  issn = {1095-1350},
  owner = {roden},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Shtern2004,
  author = {Shtern, M. and Tzerpos, V.},
  title = {A framework for the comparison of nested software decompositions},
  booktitle = {Proc. 11th Working Conference on Reverse Engineering},
  year = {2004},
  pages = {284--292},
  note = {END (Evaluation of Nested Decompositions)},
  abstract = {The evaluation of results obtained from software clustering algorithms
	has attracted the attention of many reverse engineering researchers.
	Several methods that compare flat decompositions of software systems
	have been presented in the literature. However, software clustering
	algorithms often produce nested decompositions. Converting nested
	decompositions to flat ones in order to compare them may remove significant
	information. We introduce a framework called END that reuses comparison
	methods for flat decompositions in order to compare nested decompositions
	without loss of information. We also present experimental results
	with END using several existing methods as plugins that demonstrate
	its usefulness.},
  doi = {10.1109/WCRE.2004.6},
  file = {Shtern, Tzerpos - A Framework for the Comparison of Nested Software
	Decompositions (2004).ps:papers/Shtern, Tzerpos - A Framework for
	the Comparison of Nested Software Decompositions (2004).ps:PostScript},
  issn = {1095-1350},
  keywords = {reverse engineering, software engineering, workstation clusters, END,
	comparison framework, flat decompositions, information loss, nested
	software decompositions, researcher, reverse engineering, software
	clustering algorithms},
  owner = {roden},
  timestamp = {2008.10.10}
}

@MASTERSTHESIS{Trifu2001,
  author = {Trifu},
  title = {Using Cluster Analysis in the Architecture Recovery of Object-Oriented
	Systems},
  school = {Univ. Karlsruhe},
  year = {2001},
  note = {James},
  file = {Trifu - [PhD] Using Cluster Analysis in the Architecture Recovery
	of Object-Oriented Systems (2001).pdf:papers/Trifu - [PhD] Using
	Cluster Analysis in the Architecture Recovery of Object-Oriented
	Systems (2001).pdf:PDF;Trifu - [PhD] Using Cluster Analysis in the
	Architecture Recovery of Object-Oriented Systems (2001).pdf:papers/Trifu
	- [PhD] Using Cluster Analysis in the Architecture Recovery of Object-Oriented
	Systems (2001).pdf:PDF},
  owner = {rodrigo},
  review = {Apenas 90 pginas, bom.
	
	
	Avalia com um sistema de 171 classes, o que considero pequeno.},
  timestamp = {2008.10.15}
}

@PHDTHESIS{Tzerpos2001,
  author = {Vassilios Tzerpos},
  title = {Comprehension-Driven Software Clustering},
  school = {University of Toronto},
  year = {2001},
  note = {MoJo},
  file = {Tzerpos - [PhD] Comprehension-Driven Software Clustering (2001).pdf:papers/Tzerpos
	- [PhD] Comprehension-Driven Software Clustering (2001).pdf:PDF;Tzerpos
	- [PhD] Comprehension-Driven Software Clustering (2001).pdf:papers/Tzerpos
	- [PhD] Comprehension-Driven Software Clustering (2001).pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Tzerpos2000,
  author = {Tzerpos, V. and Holt, R. C.},
  title = {ACDC: an algorithm for comprehension-driven clustering},
  booktitle = {Proc. Seventh Working Conference on Reverse Engineering},
  year = {2000},
  pages = {258--267},
  abstract = {The software clustering literature contains many different approaches
	that attempt to automatically decompose software systems. These approaches
	commonly utilize criteria or measures based on principles such as
	high cohesion and low coupling, information hiding etc. We present
	an algorithm that subscribes to a philosophy targeted towards program
	comprehension and based on subsystem patterns. We discuss the algorithm's
	implementation and describe experiments that demonstrate its usefulness},
  doi = {10.1109/WCRE.2000.891477},
  keywords = {pattern clustering, reverse engineering, software engineering, statistical
	analysis, ACCD, automatic software system decomposition, comprehension-driven
	clustering algorithm, high cohesion, information hiding, low coupling,
	program comprehension, software clustering, subsystem patterns},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Tzerpos2000a,
  author = {Tzerpos, V. and Holt, R. C.},
  title = {On the stability of software clustering algorithms},
  booktitle = {Proc. 8th International Workshop on Program Comprehension IWPC 2000},
  year = {2000},
  pages = {211--218},
  abstract = {A crucial step in understanding a large legacy software system is
	to decompose it into meaningful subsystems, which can be separately
	studied. This decomposition can be done either manually or automatically
	by a software clustering algorithm (SCA). Similar versions of a software
	system can be expected to have similar decompositions. We say an
	SCA is stable if small changes in its input (the software system)
	produce small changes in its output (the decomposition). The paper
	defines stability formally, explains why it is an essential property
	for an SCA, and gives experimental results from evaluating the stability
	of various decomposition algorithms suggested in the literature},
  doi = {10.1109/WPC.2000.852495},
  keywords = {pattern clustering, reverse engineering, software maintenance, SCA
	stability, decomposition algorithms, large legacy software system
	understanding, meaningful subsystems, software clustering algorithm
	stability},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Tzerpos1999,
  author = {Tzerpos, V. and Holt, R. C. },
  title = {MoJo: a distance metric for software clusterings},
  booktitle = {Proc. Sixth Working Conference on Reverse Engineering},
  year = {1999},
  pages = {187--193},
  note = {MoJo},
  abstract = {The software clustering problem has attracted much attention recently,
	since it is an integral part of the process of reverse engineering
	large software systems. A key problem in this research is the difficulty
	in comparing different approaches in an objective fashion. In this
	paper, we present a metric, called MoJo (Move-Join), that can be
	used in evaluating the similarity of two different decompositions
	of a software system. Our metric calculates a distance between two
	partitions of the same set of software resources. We begin by introducing
	the model we use. Then we present a heuristic algorithm that calculates
	the distance in an efficient fashion. Finally, we discuss some experiments
	that showcase the performance of the algorithm and the effectiveness
	of the metric},
  doi = {10.1109/WCRE.1999.806959},
  keywords = {heuristic programming, reverse engineering, software metrics, software
	performance evaluation, MoJo software metric, algorithm performance,
	cluster joining, cluster moving, distance metric, heuristic algorithm,
	large software systems, reverse engineering, software clusterings,
	software resource partitioning, software system dcomposition},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Tzerpos1998,
  author = {Tzerpos, V. and Holt, R. C. },
  title = {Software botryology. Automatic clustering of software systems},
  booktitle = {Proc. Ninth International Workshop on Database and Expert Systems
	Applications},
  year = {1998},
  pages = {811--818},
  abstract = {It has long been recognized that the decomposition of a large software
	system into &ldquo;meaningful&rdquo; subsystems is essential for
	both the development and maintenance phases of a software project.
	We introduce the term &ldquo;software botryology&rdquo; for the area
	of research that attempts to automatically cluster a software system
	(&ldquo;botrys&rdquo; is the ancient Greek word for a cluster of
	grapes). In this paper, we survey approaches to the clustering problem
	from researchers in the software engineering community. We also present
	clustering techniques used in other disciplines and argue that their
	utilization in a software context could lead to better solutions
	to the software clustering problem. Finally, we outline research
	challenges and open problems of interest},
  doi = {10.1109/DEXA.1998.707499},
  keywords = {computer aided software engineering, large-scale systems, pattern
	recognition, automatic software systems clustering, large software
	systems, meaningful subsystems, software botryology, software clustering,
	software development, software engineering, software maintenance,
	software project, software system decomposition},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Tzerpos1997,
  author = {Tzerpos, V. and Holt, R. C. },
  title = {The Orphan Adoption problem in architecture maintenance},
  booktitle = {Proc. Fourth Working Conference on Reverse Engineering},
  year = {1997},
  pages = {76--82},
  abstract = {A lot of research time has been devoted to finding a solution to the
	problem of automatic clustering, especially in the field of reverse
	engineering, where decomposing a legacy system to subsystems could
	be the key to understanding it. Maintaining the obtained structure
	as a system evolves, however, is a problem that has attracted much
	less attention. We present the Orphan Adoption problem in architecture
	maintenance, and propose an algorithm to solve it. We also present
	case studies that validate the usefulness of our algorithm},
  doi = {10.1109/WCRE.1997.624578},
  keywords = {computer aided software engineering, resource allocation, reverse
	engineering, software maintenance, Orphan Adoption problem, architecture
	maintenance, automatic clustering, case studies, legacy system, reverse
	engineering},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@MISC{Vasconcelos2008,
  author = {Vasconcelos and Werner},
  title = {Architecture Recovery and Evaluation Aiming at Program Understanding
	and Reuse},
  year = {2008},
  __markedentry = {[roden]},
  owner = {roden},
  timestamp = {2008.10.21}
}

@ARTICLE{Vasconcelos2008a,
  author = {Vasconcelos and Werner},
  title = {Refining the Architecture Recovery Approach ArchMine by Incrementally
	Performing Evaluation Studies},
  year = {2008},
  note = {SBES 2008. Tenho impresso.},
  __markedentry = {[roden]},
  owner = {roden},
  timestamp = {2008.10.21}
}

@INPROCEEDINGS{Vasconcelos2004,
  author = {Vasconcelos and Werner},
  title = {Software architecture recovery based on dynamic analysis},
  booktitle = {Brazilian Symposium on Software Engineering},
  year = {2004},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Wen2005,
  author = {Wen, Z. and Tzerpos, V. },
  title = {Software clustering based on omnipresent object detection},
  booktitle = {Proc. 13th International Workshop on Program Comprehension IWPC 2005},
  year = {2005},
  pages = {269--278},
  abstract = {The detection of omnipresent objects can be an important aid to the
	process of understanding a large software system. As a result, various
	detection techniques have been presented in the literature. However,
	these techniques do not take the subsystem structure into account
	when deciding whether an object is omnipresent or not. In this paper,
	we present a new set of detection methods for omnipresent objects
	that maintain that an object needs to be connected to a large number
	of subsystems before it is deemed omnipresent. We compare this novel
	approach to existing ones. We also introduce a framework that can
	improve the effectiveness of existing software clustering algorithms
	by combining them with an omnipresent object detection method. Experiments
	with two large software systems demonstrate the usefulness of this
	framework.},
  doi = {10.1109/WPC.2005.31},
  issn = {1092-8138},
  keywords = {object-oriented programming, reverse engineering, software maintenance,
	object-oriented programming, omnipresent object detection, software
	clustering, software maintenance, software subsystem structure, software
	system understanding},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@INPROCEEDINGS{Wen2004,
  author = {Wen, Zhihua and Tzerpos, V.},
  title = {An effectiveness measure for software clustering algorithms},
  booktitle = {Proc. 12th IEEE International Workshop on Program Comprehension},
  year = {2004},
  pages = {194--203},
  note = {MoJoFM},
  abstract = {Selecting an appropriate software clustering algorithm that can help
	the process of understanding a large software system is a challenging
	issue. The effectiveness of a particular algorithm may be influenced
	by a number of different factors, such as the types of decompositions
	produced, or the way clusters are named. In this paper, we introduce
	an effectiveness measure for software clustering algorithms based
	on Mojo distance, and describe an algorithm that calculates its value.
	We also present experiments that demonstrate its improved performance
	over previous measures, and show how it can be used to assess the
	effectiveness of software clustering algorithms.},
  doi = {10.1109/WPC.2004.1311061},
  issn = {1092-8138},
  keywords = {reverse engineering, Mojo distance, software clustering, software
	system, software understanding},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Wen2004a,
  author = {Wen, Zhihua and Tzerpos, V.},
  title = {Evaluating similarity measures for software decompositions},
  booktitle = {Proc. 20th IEEE International Conference on Software Maintenance},
  year = {2004},
  pages = {368--377},
  note = {EdgeMoJo},
  abstract = {One of the central questions that a similarity measure for software
	decompositions has to address is whether to consider discrepancies
	in terms of the nodes of a particular decomposition, or assess similarity
	based on differences in clustering the edges of the system's dependency
	graph. We argue that considering nodes or edges in isolation is too
	one-sided. We outline shortcomings of previous approaches, and introduce
	the first dissimilarity measure that takes both nodes and edges into
	account. We also present experiments on real and synthetic data sets
	that illustrate the differences between various measures.},
  doi = {10.1109/ICSM.2004.1357822},
  issn = {1063-6773},
  keywords = {software metrics, software performance evaluation, edge clustering,
	similarity measure evaluation, software decomposition, system dependency
	graph},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@INPROCEEDINGS{Wen2003,
  author = {Wen, Zhihua and Tzerpos, V. },
  title = {An optimal algorithm for MoJo distance},
  booktitle = {Proc. 11th IEEE International Workshop on Program Comprehension},
  year = {2003},
  pages = {227--235},
  note = {MoJo},
  abstract = {Effective comparison of different decompositions of a software system
	is integral for the evaluation of software clustering algorithms.
	One of the approaches that has been developed to tackle this issue
	is the MoJo distance measure. The original algorithm for the computation
	of MoJo distance was a heuristic one that only approximated the exact
	value. In this paper we introduce an algorithm that calculates the
	exact distance in polynomial time. We also present experiments that
	showcase that the new algorithm calculates MoJo distance more accurately
	and efficiently than before.},
  doi = {10.1109/WPC.2003.1199206},
  issn = {1092-8138},
  keywords = {reverse engineering, MoJo distance measure, optimal algorithm, software
	clustering algorithms, software system, software understanding},
  owner = {rodrigo},
  timestamp = {2008.10.10}
}

@MISC{,
  author = {Wu and Holt},
  title = {A Program Extractor Suite for C and C++: Choosing the Right Tool
	for the Job},
  year = {2006},
  owner = {rodrigo},
  review = {Ferramentas analisadas:
	
	* CPPX
	
	* BFX
	
	* LDX 
	
	* CTSX},
  timestamp = {2008.10.25}
}

@INPROCEEDINGS{Wu2005,
  author = {Wu, J. and Hassan, A. E. and Holt, R. C.},
  title = {Comparison of clustering algorithms in the context of software evolution},
  booktitle = {Proc. 21st IEEE International Conference on ICSM'05 Software Maintenance},
  year = {2005},
  pages = {525--535},
  abstract = {To aid software analysis and maintenance tasks, a number of software
	clustering algorithms have been proposed to automatically partition
	a software system into meaningful subsystems or clusters. However,
	it is unknown whether these algorithms produce similar meaningful
	clusterings for similar versions of a real-life software system under
	continual change and growth. This paper describes a comparative study
	of six software clustering algorithms. We applied each of the algorithms
	to subsequent versions from five large open source systems. We conducted
	comparisons based on three criteria respectively: stability (Does
	the clustering change only modestly as the system undergoes modest
	updating?), authoritative-ness (Does the clustering reasonably approximate
	the structure an authority provides?) and extremity of cluster distribution
	(Does the clustering avoid huge clusters and many very small clusters?).
	Experimental results indicate that the studied algorithms exhibit
	distinct characteristics. For example, the clusterings from the most
	stable algorithm bear little similarity to the implemented system
	structure, while the clusterings from the least stable algorithm
	has the best cluster distribution. Based on obtained results, we
	claim that current automatic clustering algorithms need significant
	improvement to provide continual support for large software projects.},
  doi = {10.1109/ICSM.2005.31},
  file = {Comparison of Clustering Algorithms in the Context of Software Evolution.pdf:papers/Comparison
	of Clustering Algorithms in the Context of Software Evolution.pdf:PDF},
  issn = {1063-6773},
  keywords = {public domain software, software maintenance, software prototyping,
	authoritativeness criteria, automatic clustering algorithm, cluster
	distribution criteria, open source system, real-life software system,
	software clustering algorithm, software evolution, software maintenance,
	software projects, stability criteria},
  owner = {rodrigo},
  review = {Extrator de cdigo C++ usado: CTSX},
  timestamp = {2008.10.10}
}

@MISC{Xanthos2006,
  author = {Xanthos},
  title = {Clustering Object-Oriented Software Systems using Spectral Graph
	Partitioning},
  year = {2006},
  file = {Xanthos - Clustering Object-Oriented Software Systems using Spectral
	Graph Partitioning.pdf:papers/Xanthos - Clustering Object-Oriented
	Software Systems using Spectral Graph Partitioning.pdf:PDF},
  owner = {rodrigo},
  timestamp = {2008.10.15}
}

@INPROCEEDINGS{Xiao2005,
  author = {Xiao, Chenchen and Tzerpos, V. },
  title = {Software Clustering Based on Dynamic Dependencies},
  booktitle = {Proc. Ninth European Conference on Software Maintenance and Reengineering
	CSMR 2005},
  year = {2005},
  pages = {124--133},
  abstract = {The reverse engineering literature contains many software clustering
	approaches that attempt to cluster large software systems based on
	the static dependencies between software artifacts. However, the
	usefulness of clustering based on dynamic dependencies has not been
	investigated. It is possible that dynamic clusterings can provide
	a fresh outlook on the structure of a large software system. In this
	paper, we present an approach for the evaluation of dynamic clusterings.
	We apply this approach to a large open source software system, and
	present experimental results that suggest that dynamic clusterings
	have considerable merit.},
  doi = {10.1109/CSMR.2005.49},
  issn = {1534-5351},
  keywords = {program diagnostics, public domain software, reverse engineering,
	dynamic clustering evaluation, open source software system, reverse
	engineering, software artifacts, software clustering, static dependency},
  owner = {rodrigo},
  timestamp = {2008.10.12}
}

@article{Millo2004,
    abstract = {Complex biological, technological, and sociological networks can be of very different sizes and connectivities, making it difficult to compare their structures. Here we present an approach to systematically study similarity in the local structure of networks, based on the significance profile (SP) of small subgraphs in the network compared to randomized networks. We find several superfamilies of previously unrelated networks with very similar SPs. One superfamily, including transcription networks of microorganisms, represents "rate-limited" information-processing networks strongly constrained by the response time of their components. A distinct superfamily includes protein signaling, developmental genetic networks, and neuronal wiring. Additional superfamilies include power grids, protein-structure networks and geometric networks, World Wide Web links and social networks, and word-adjacency networks from different languages.},
    address = {Departments of Molecular Cell Biology, Physics of Complex Systems, and Computer Science, Weizmann Institute of Science, Rehovot 76100, Israel.},
    author = {Milo, R. and Itzkovitz, S. and Kashtan, N. and Levitt, R. and Shen-Orr, S. and Ayzenshtat, I. and Sheffer, M. and Alon, U.},
    citeulike-article-id = {363614},
    citeulike-linkout-0 = {http://dx.doi.org/10.1126/science.1089167},
    citeulike-linkout-1 = {http://www.sciencemag.org/cgi/content/abstract/303/5663/1538},
    citeulike-linkout-2 = {http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=2004Sci...303.1538M},
    citeulike-linkout-3 = {http://view.ncbi.nlm.nih.gov/pubmed/15001784},
    citeulike-linkout-4 = {http://www.hubmed.org/display.cgi?uids=15001784},
    doi = {10.1126/science.1089167},
    issn = {1095-9203},
    journal = {Science},
    keywords = {analysis, evolution, motif, network},
    month = {March},
    number = {5663},
    pages = {1538--1542},
    posted-at = {2009-04-23 14:53:05},
    priority = {3},
    title = {Superfamilies of evolved and designed networks.},
    url = {http://dx.doi.org/10.1126/science.1089167},
    volume = {303},
    year = {2004}
}

@article{Jeong2000,
    abstract = {In a cell or microorganism, the processes that generate mass, energy, information transfer and cell-fate specification are seamlessly integrated through a complex network of cellular constituents and reactions. However, despite the key role of these networks in sustaining cellular functions, their large-scale structure is essentially unknown. Here we present a systematic comparative mathematical analysis of the metabolic networks of 43 organisms representing all three domains of life. We show that, despite significant variation in their individual constituents and pathways, these metabolic networks have the same topological scaling properties and show striking similarities to the inherent organization of complex non-biological systems. This may indicate that metabolic organization is not only identical for all living organisms, but also complies with the design principles of robust and error-tolerant scale-free networks, and may represent a common blueprint for the large-scale organization of interactions among all cellular constituents.},
    address = {Department of Physics, University of Notre Dame, Indiana 46556, USA.},
    author = {Jeong, H. and Tombor, B. and Albert, R. and Oltvai, Z. N. and Barabasi, A. L.},
    citeulike-article-id = {238},
    citeulike-linkout-0 = {http://dx.doi.org/10.1038/35036627},
    citeulike-linkout-1 = {http://dx.doi.org/10.1038/407651a0},
    citeulike-linkout-2 = {http://view.ncbi.nlm.nih.gov/pubmed/11034217},
    citeulike-linkout-3 = {http://www.hubmed.org/display.cgi?uids=11034217},
    doi = {10.1038/35036627},
    issn = {0028-0836},
    journal = {Nature},
    keywords = {biochemical, complex, distribution, lengths, metabolic, metabolic\_networks, network, networksconnectivity, of, path, pathway, properties, ranking, shortest, substrate},
    month = {October},
    number = {6804},
    pages = {651--654},
    posted-at = {2009-09-02 00:28:35},
    priority = {0},
    title = {The large-scale organization of metabolic networks},
    url = {http://dx.doi.org/10.1038/35036627},
    volume = {407},
    year = {2000}
}

@ARTICLE{Jeong2001,
  author = {Hawoong Jeong and Sean P. Mason and Albert-Laszlo Barabasi and Zoltan N. Oltvai},
  title = {Lethality and centrality in protein networks},
  journal = {NATURE v},
  volume = {411},
  pages = {41},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0105306},
  year = {2001}
}


@MISC{Traud2008,
  author = {Amanda L. Traud and Eric D. Kelsic and Peter J. Mucha and Mason A. Porter},
  title = {Community Structure in Online Collegiate Social Networks},
  url = {http://www.citebase.org/abstract?id=oai:arXiv.org:0809.0690},
  year = {2008}
}

@inproceedings{Adamic2005,
    address = {New York, NY, USA},
    author = {Adamic, Lada A. and Glance, Natalie},
    booktitle = {LinkKDD '05: Proceedings of the 3rd international workshop on Link discovery},
    citeulike-article-id = {1244437},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1134271.1134277},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1134271.1134277},
    doi = {10.1145/1134271.1134277},
    isbn = {1595932151},
    keywords = {blog, blogosphere, blogs, polictical},
    pages = {36--43},
    posted-at = {2007-09-16 16:25:01},
    priority = {2},
    publisher = {ACM Press},
    title = {The political blogosphere and the 2004 U.S. election: divided they blog},
    url = {http://dx.doi.org/10.1145/1134271.1134277},
    year = {2005}
}

@techreport{Northrop2006,
  author = {Linda Northrop and Peter Feiler and Richard P. Gabriel and John Goodenough and Rick Linger and Tom Longstaff and Rick Kazman and Mark Klein and Douglas Schmidt and Kevin Sullivan and Kurt Wallnau},
  editor = {William Pollak},
  institution = {Software Engineering Institute, Carnegie Mellon},
  interHash = {410c990a2cf3a6256a37ea03a00f6826},
  intraHash = {937be554b7d590fb3ec152b91528488d},
  title = {{Ultra-Large-Scale Systems - The Software Challenge of the Future}},
  url = {http://www.sei.cmu.edu/uls/downloads.html},
  year = {2006},
  month = {June},
}

@comment{jabref-meta: selector_publisher:}

@comment{jabref-meta: selector_author:}

@comment{jabref-meta: selector_journal:}

@comment{jabref-meta: selector_keywords:}

@comment{jabref-meta: groupsversion:3;}

@comment{jabref-meta: groupstree:
0 AllEntriesGroup:;
1 ExplicitGroup:Metrics for comparison of decompositions\;0\;Anquetil1
999\;Koschke2000\;Lakhotia1995\;Mitchell2001\;Mitchell2002\;Shtern2004
\;Shtern2007\;Tzerpos1999\;Tzerpos2001\;Wen2003\;Wen2004\;Wen2004a\;;
1 ExplicitGroup:Decomposition algorithm\;0\;Andritsos2005\;Mancoridis1
998\;;
1 ExplicitGroup:Lidos\;0\;Andreopoulos2005\;Anquetil1997\;Anquetil1999
\;Huynh2008\;Lindvall2008\;Maqbool2007\;Pollet2007\;Shtern2004\;;
1 ExplicitGroup:2008-10-20\;0\;Ding2001\;Li2005\;Mendonca1999\;;
}

